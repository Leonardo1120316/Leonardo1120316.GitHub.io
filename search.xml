<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>页面的cookie，local Storage，Session Storage</title>
      <link href="/2023/03/28/cookie%EF%BC%8Csession%EF%BC%8Ctoken/"/>
      <url>/2023/03/28/cookie%EF%BC%8Csession%EF%BC%8Ctoken/</url>
      
        <content type="html"><![CDATA[<p>##一、异同点</p><p>相同：都是写在浏览器的，存储在浏览器的</p><p>不同点：cookie由后端写入，session和local storage由前端写入</p><p>cookie的生命周期由后端设定，local storage需要手动清除否则不会删除，session在页面关闭时删除</p><p>前端发送请求时会自动携带cookie数据</p><h2 id="二、token"><a href="#二、token" class="headerlink" title="二、token"></a>二、token</h2><p>token通常用于判断用户是否登录，它存储在cookie中，它内部包含的信息有：uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串） <code>token</code>可以存放在<code>Cookie</code>中，<code>token</code> 是否过期，应该由后端来判断，不该前端来判断，所以<code>token</code>存储在<code>cookie</code>中只要不设置<code>cookie</code>的过期时间就ok了，如果 <code>token</code> 失效，就让后端在接口中返回固定的状态表示<code>token</code> 失效，需要重新登录，再重新登录的时候，重新设置 <code>cookie</code> 中的 <code>token</code> 就行。   </p><p> token认证流程 1. 客户端使用用户名跟密码请求登录 2. 服务端收到请求，去验证用户名与密码 3. 验证成功后，服务端签发一个 token ，并把它发送给客户端 4. 客户端接收 token 以后会把它存储起来，比如放在  cookie 里或者 localStorage 里 5. 客户端每次发送请求时都需要带着服务端签发的 token（把 token 放到 HTTP 的 Header 里） 6. 服务端收到请求后，需要验证请求里带有的 token ，如验证成功则返回对应的数据</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js实现异步的方法</title>
      <link href="/2023/03/28/JS%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2023/03/28/JS%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>##一、回调函数</p><p>什么是JavaScript回调函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function A(callback)&#123;</span><br><span class="line">  console.log(&quot;A&quot;)</span><br><span class="line">  callback()</span><br><span class="line">&#125;</span><br><span class="line">function B()&#123;</span><br><span class="line">  console.log(&quot;B&quot;)</span><br><span class="line">&#125;</span><br><span class="line">A(B)</span><br><span class="line">//这里使用了回调函数A</span><br></pre></td></tr></table></figure><p>当B函数是A函数的入参，且A函数使用了B函数，我们把A函数称为回调函数</p><p>setTimeout，ajax回调，dom回调都是回调函数，都为异步方法</p><h2 id="二、Promise"><a href="#二、Promise" class="headerlink" title="二、Promise"></a>二、Promise</h2><p>promise本身是同步的，promise的then的内容是异步</p><h2 id="三、Generator函数（ES6"><a href="#三、Generator函数（ES6" class="headerlink" title="三、Generator函数（ES6)"></a>三、Generator函数（ES6)</h2><p>Generator分段函数是一个可以暂停执行的函数（分段函数）</p><p>使用*定义分段函数，在函数中封装了多个状态，使用yield和return分段，yield标记函数暂停位置，return表示结束返回，调用时使用next()方法使指针指向下一个状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function *myGenerator()&#123;</span><br><span class="line">  yield &quot;confusing&quot;</span><br><span class="line">  yield &quot;interesting&quot;</span><br><span class="line">  yield &quot;relaxing&quot;</span><br><span class="line">  return &quot;amazing&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用分段函数的next()方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var h = myGenerator()</span><br><span class="line">console.log(h.next())</span><br><span class="line">//输出&#123;value: &#x27;confusing&#x27;, done: false&#125;</span><br></pre></td></tr></table></figure><p>注意输出为一个对象包含value和done</p><h2 id="四、async，await函数（ES7）"><a href="#四、async，await函数（ES7）" class="headerlink" title="四、async，await函数（ES7）"></a>四、async，await函数（ES7）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function mysw()&#123;</span><br><span class="line">    let a = await new Promise((resolve) =&gt; &#123;</span><br><span class="line">        resolve(&quot;a&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(a);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">mysw().then((res) =&gt; &#123;</span><br><span class="line">    console.log(res);//输出a,1,返回一个PromiseResult为undefined的promise</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>看起来async&#x2F;await和Generator用法相似，把星号换成async，把yield换成await，它们区别在于：</p><p>1，async函数自带执行器</p><p>2，语义清楚</p><p>3，async函数的返回值是 Promise 对象，Generator 函数的返回值是 Iterator 对象</p><p>4，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值**</p><p>await语句后面的内容需要等待await的内容执行完才能执行（宏任务除外），可以把await当成是then的语法糖，await之后的内容就相当于then里的回调函数，是异步，根据先微后宏的顺序继续执行</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js继承方法</title>
      <link href="/2023/03/26/js%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95/"/>
      <url>/2023/03/26/js%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>##一、js中的继承</p><p>js中的继承是一种委托机制，对象将方法和属性委托到原型上，这样多个对象就可以共享一个原型上的属性和方法，这个过程没有复制粘贴。js继承依靠于原型链，原型可以是一个对象的原型也可以是另外一个原型的实例</p><p>##二、js的六种继承方法</p><p>1.原型链继承：子类构造函数的prototype指向父类构造函数new出的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function father()&#123;</span><br><span class="line">  this.name = &quot;Jack&quot;</span><br><span class="line">  this.age = 40</span><br><span class="line">&#125;</span><br><span class="line">function child()&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">//设置继承关系让child继承father</span><br><span class="line">child.prototype = new father()</span><br><span class="line">var children = new child()</span><br><span class="line">console.log(children.name)</span><br><span class="line">//输出Jack</span><br></pre></td></tr></table></figure><p>2.原型继承的缺点</p><p>如果father原型中成员为引用数据类型，例如数组，操作该数组例如push会改变所有实例中的继承成员变量的值</p><p>无法向父类构造函数传输参数</p><p>3.盗用构造函数的继承方式</p><p>当使用子类构造函数prototype继承父类的构造函数时，无法通过子类构造函数向父类构造函数输入参数，此时使用盗用构造函数的方法，即在子类构造函数定义中写入调用父类构造函数的句子，并通过call方法将构造函数指向修改为当前构造函数的指向（即新new出来的子类实例）并在call函数中的第二个参数中输入传给父类构造函数的参数</p><p>PS:此时定义的父类构造函数本身需要允许传入参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function father(eyes)&#123;</span><br><span class="line">  this.eyes = eyes</span><br><span class="line">  this.color = &quot;pink&quot;</span><br><span class="line">&#125;</span><br><span class="line">function children(color)&#123;</span><br><span class="line">  father.call(this,color)</span><br><span class="line">&#125;</span><br><span class="line">var child = new children(&quot;pink&quot;)</span><br><span class="line">console.log(child.eyes)</span><br><span class="line">//输出结果pink</span><br></pre></td></tr></table></figure><p><strong>问题：</strong></p><ol><li><strong>必须在构造函数中定义方法，通过盗用构造函数继承的方式本质上都变成了实例自己的方法，不是公共的方法，因此失去了复用性。</strong></li><li><strong>子类不能访问父类原型上定义的方法。</strong></li></ol><h2 id="三、组合继承"><a href="#三、组合继承" class="headerlink" title="三、组合继承"></a>三、组合继承</h2><p>即同时使用原型链继承和盗用构造函数继承</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function Person(eyes) &#123;</span><br><span class="line">    this.eyes = eyes</span><br><span class="line">    this.colors = [&#x27;white&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getEyes = function () &#123;</span><br><span class="line">    return this.eyes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function YellowRace()&#123;</span><br><span class="line">    Person.call(this,&#x27;black&#x27;);// 调用构造函数并传参</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">YellowRace.prototype = new Person(); // 再次调用构造函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const nz = new YellowRace();</span><br><span class="line">nz.colors.push(&#x27;green&#x27;);</span><br><span class="line"></span><br><span class="line">const laowang = new YellowRace();</span><br><span class="line"></span><br><span class="line">console.log(nz.colors); //[ &#x27;white&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;, &#x27;green&#x27; ]</span><br><span class="line">console.log(laowang.colors); //[ &#x27;white&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27; ]</span><br><span class="line"></span><br><span class="line">console.log(nz.getEyes()); //black </span><br></pre></td></tr></table></figure><p>缺点：有一定资源浪费（调用了两次构造函数）</p><h2 id="四、原型式继承"><a href="#四、原型式继承" class="headerlink" title="四、原型式继承"></a>四、原型式继承</h2><p>定义函数，传入对象，在函数中将这个对象作为一个空构造函数的原型，返回这个构造函数的实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//定义函数</span><br><span class="line">function obj(o)&#123;</span><br><span class="line">  function F()&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  return new F()</span><br><span class="line">&#125;</span><br><span class="line">//定义一个对象</span><br><span class="line">var h = &#123;</span><br><span class="line">  name:&quot;Jack&quot;,</span><br><span class="line">  age:19</span><br><span class="line">&#125;</span><br><span class="line">//传入上面函数</span><br><span class="line">var f = obj(h)</span><br><span class="line">console.log(f.name)</span><br><span class="line">//输出name为Jack</span><br></pre></td></tr></table></figure><p>以上函数可以简化为使用es6自带函数object.create()</p><p>当object.create()函数只有一个参数时与上面的obj函数作用相同，传入参数的意义相同</p><p>当object.create()函数含有多个参数时，后面带的是传参数</p><ol><li>使用手写的object()不能传参，使用Object.create()可以传参</li><li>原对象中的引用类型的属性会被新对象共享。</li></ol><h2 id="五、-寄生式继承"><a href="#五、-寄生式继承" class="headerlink" title="五、 寄生式继承"></a>五、 寄生式继承</h2><p>在原型继承的基础上以某种形式增强（例如加入一个新的函数）再返回这个对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function inherit(o)&#123;</span><br><span class="line">    let clone = Object.create(o); // 增强对象</span><br><span class="line">    clone.sayHi = function()&#123;</span><br><span class="line">        console.log(&#x27;hi&#x27;);</span><br><span class="line">    &#125;;</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const nz = &#123;</span><br><span class="line">    eyes: &#x27;black&#x27;,</span><br><span class="line">    colors: [&#x27;white&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const laowang = inherit(nz);</span><br><span class="line">console.log(laowang.eyes);  // black</span><br><span class="line">console.log(laowang.colors); // [ &#x27;white&#x27;, &#x27;yellow&#x27;, &#x27;black&#x27; ]</span><br><span class="line"></span><br><span class="line">laowang.sayHi(); // hi</span><br></pre></td></tr></table></figure><h2 id="六、寄生式组合继承"><a href="#六、寄生式组合继承" class="headerlink" title="六、寄生式组合继承"></a>六、寄生式组合继承</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js new关键字</title>
      <link href="/2023/03/26/JSnew/"/>
      <url>/2023/03/26/JSnew/</url>
      
        <content type="html"><![CDATA[<p>##一、js new之后执行操作</p><p>1.创建一个空对象</p><p>2.为该对象添加属性_proto__，关联到对象的原型上</p><p>3.将创建的对象作为this的上下文</p><p>4.如果该函数没有return返回值，则返this</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>defer和async区别</title>
      <link href="/2023/03/26/defer%E5%92%8Casync/"/>
      <url>/2023/03/26/defer%E5%92%8Casync/</url>
      
        <content type="html"><![CDATA[<p>##一、defer和async</p><script src="script.js"></script><p>没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。</p><script async src="script.js"></script><p>有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。</p><script defer src="myscript.js"></script><p>有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded事件触发之前完成。</p><p><img src="https://img-blog.csdnimg.cn/20190924222353217.png"></p><p>正常js执行在html解释中，读取到js代码，就截断html解释，加载并执行js</p><p>async的js允许异步加载js，当是需要解释完成html后才会执行js</p><p>defer允许js异步加载，并在加载完成后截断html解释，执行js后继续解释</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩展运算符（...）</title>
      <link href="/2023/03/25/%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88...%EF%BC%89/"/>
      <url>/2023/03/25/%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88...%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>##一、字面量</p><p>属性简洁表示方法ES6允许对象的属性直接写变量，这时候属性名是变量名，属性值是变量值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;Jack&quot;</span><br><span class="line">var age = 19</span><br><span class="line">var person=&#123;</span><br><span class="line">  name,</span><br><span class="line">  age,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意字面量简写需要提前定义并建议赋值</p><p>##二、扩展运算符作用</p><p>在语法上展开数组，字面量对象，字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//一下定义了两个字面量a和b，用拓展运算符号将两个对象展开赋值给c</span><br><span class="line">var name =&quot;Jack&quot;</span><br><span class="line">var age = 19</span><br><span class="line">var sex = &quot;man&quot;</span><br><span class="line">var school = &quot;zj&quot;</span><br><span class="line">var a =&#123;name,age&#125;</span><br><span class="line">var b =&#123;sex,school&#125;</span><br><span class="line">var c =&#123;...b,...a&#125;</span><br><span class="line">console.log(c)</span><br><span class="line">//结果为&#123;sex: &#x27;man&#x27;, school: &#x27;zj&#x27;, name: &#x27;Jack&#x27;, age: 19&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="三、扩展运算符使用场景"><a href="#三、扩展运算符使用场景" class="headerlink" title="三、扩展运算符使用场景"></a>三、扩展运算符使用场景</h2><p>等价于apply的方式、将数组展开为构造函数的参数、字面量数组或字符串连接不需要使用concat等方法了、构造字面量对象时,进行浅克隆或者属性拷贝</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Js变量提升</title>
      <link href="/2023/03/25/Js%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
      <url>/2023/03/25/Js%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
      
        <content type="html"><![CDATA[<p>##一、变量提升</p><p>js中let和const定义的变量不会提升，只有var定义的变量会提升，变量提升只提升声明，赋值并不会提升，函数声明提升先于变量</p><p>变量提升的优点：可以在初始化之前访问变量，在声明前调用函数</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apply,bind,call函数改变this指向</title>
      <link href="/2023/03/25/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
      <url>/2023/03/25/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p>##一、普通函数的this指向</p><p>1.对于不同调用方法指向不同</p><p>对于一个对象的成员函数，利用对象调用函数时this指向该成员</p><p>直接调用函数函数this指向window</p><p>2.apply,call,bind改变函数this指向</p><p>apply(this指向,arrParams) call(this指向,params) bind(this指向,params)</p><p>call，bind分别输入参数，call输入参数组成的数组</p><p>call，apply在输入后执行该函数，bind在输入后返回修改指向的函数</p><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//定义一个c函数</span><br><span class="line">function c()&#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">    &#125;</span><br><span class="line">//执行c输出window</span><br><span class="line">    c()</span><br><span class="line">    var b = 2;</span><br><span class="line">    var a = 1;</span><br><span class="line">//call修改指向输出指向为a</span><br><span class="line">    c.call(a)</span><br><span class="line">//bind修改指向为b，返回函数d</span><br><span class="line">    var d = c.bind(b)</span><br><span class="line">    d();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Js作用域与闭包</title>
      <link href="/2023/03/25/Js%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/"/>
      <url>/2023/03/25/Js%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>##一、Js闭包</p><p>闭包是一个函数和词法环境捆绑在一起形成的组合。一般就是一个A函数中return一个B函数，外界可以通过这个B函数访问A函数的变量。这个时候形成了B函数的变量背包，这个背包A函数执行完毕也不会销毁，且这个变量背包外界只能通过B函数访问</p><p>##二、闭包的原理</p><p>作用域链，即当前函数可以访问当前函数和上一级函数的变量</p><h2 id="三、闭包解决的问题"><a href="#三、闭包解决的问题" class="headerlink" title="三、闭包解决的问题"></a>三、闭包解决的问题</h2><p>能够使函数在外部访问到内部变量，能让内部变量在函数调用完成后不被销毁</p><p>闭包带来的问题</p><p>内存泄露，内存溢出</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map与foreach区别</title>
      <link href="/2023/03/25/map%E4%B8%8Eforeach%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/03/25/map%E4%B8%8Eforeach%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>##一、map与foreach基本用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3,4,5]</span><br><span class="line">a.foreach((item,index,arr)=&gt;&#123;</span><br><span class="line">执行内容</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>匿名函数支持三个参数，分别为item当前对象，index当前索引，arr原数组</p><p>map用法类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3,4,5]</span><br><span class="line">a.map((item,index,arr)=&gt;&#123;</span><br><span class="line">执行内容</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>##二、foreach和map的不同点</p><p>(1)map()方法会得到一个新的数组并返回，forEach()会修改原来的数组。</p><p>map遍历的后的数组通常都是生成一个新的数组，新的数组的值发生变化，当前遍历的数组值不会变化。</p><p>(2)forEach()允许callback更改原始数组的元素。map()返回新的数组。</p><p>forEach遍历通常都是直接引入当前遍历数组的内存地址，生成的数组的值发生变化，当前遍历的数组对应的值也会发生变化。</p><p>总结：foreach中无法返回值，map可以再callback中return来返回值</p><p>map，foreach可以使用匿名函数支持的arr参数来修改原数组</p><h2 id="三、foreach和map的共同点"><a href="#三、foreach和map的共同点" class="headerlink" title="三、foreach和map的共同点"></a>三、foreach和map的共同点</h2><p>(1)都是循环遍历数组中的每一项。</p><p>(2)每次执行匿名函数都支持三个参数，参数分别为item(当前每一项)，index(索引值)，arr(原数组)。</p><p>(3)匿名函数中的this都是指向window。</p><p>(4)只能遍历数组。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6箭头函数</title>
      <link href="/2023/03/25/es6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
      <url>/2023/03/25/es6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>##一、什么箭头函数</p><p>箭头函数是es6新特性，es6允许使用箭头函数定义函数，语法上类似匿名函数</p><p>如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var f = (name)=&gt;&#123;console.log(name)&#125;</span><br><span class="line">//等同于</span><br><span class="line">function f(name)&#123;</span><br><span class="line">  console.log(name)</span><br><span class="line">&#125;</span><br><span class="line">//调用f函数，输出“Jack”</span><br><span class="line">f(&quot;Jack&quot;)</span><br><span class="line">//另外,下面此时返回值是对象&#123;a:&#x27;1&#x27;,b:&#x27;2&#x27;&#125;</span><br><span class="line">var ff = (name)=&gt;(&#123;a:&#x27;1&#x27;,b:&#x27;2&#x27;&#125;)</span><br></pre></td></tr></table></figure><p>##二、箭头函数指向原则</p><p>我们知道，在匿名函数中，this是有指向的</p><p>例如 数组foreach,map函数，this指向的是window</p><p>但是在箭头函数中this没有指向，因为箭头函数没有prototype，但是箭头函数会从外部上下文获取this指向</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组与伪数组</title>
      <link href="/2023/03/25/%E6%95%B0%E7%BB%84%E4%B8%8E%E4%BC%AA%E6%95%B0%E7%BB%84/"/>
      <url>/2023/03/25/%E6%95%B0%E7%BB%84%E4%B8%8E%E4%BC%AA%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>yi常见的伪数组</p><p>##一、常见的伪数组</p><p>1函数内部的 <code>arguments</code></p><p>2 DOM 对象列表（比如通过 <code>document.getElementsByTags</code> 得到的列表）</p><p>3 jQuery 对象（比如 <code>$(&quot;div&quot;)</code> ）</p><p>伪数组是一个 Object，而真实的数组是一个 Array。</p><h2 id="二、伪数组与数组区别"><a href="#二、伪数组与数组区别" class="headerlink" title="二、伪数组与数组区别"></a>二、伪数组与数组区别</h2><p>数组类型为Array，伪数组类型Object，数组伪数组都可以使用length查看长度，使用for in遍历，使用[index]来获取数组对象，</p><p>但伪数组不能使用数组方法，修改数组长度</p><h2 id="三、伪数组转换"><a href="#三、伪数组转换" class="headerlink" title="三、伪数组转换"></a>三、伪数组转换</h2><p>Array.prototype.slice.call(伪数组)  -[].slice.call(伪数组)  -Array.from(伪数组) 转换后的数组长度由 <code>length</code> 属性决定。索引不连续时转换结果是连续的，会自动补位。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>null和undefined区别</title>
      <link href="/2023/03/24/null%E5%92%8Cundefined%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/03/24/null%E5%92%8Cundefined%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="一、null与undefined"><a href="#一、null与undefined" class="headerlink" title="一、null与undefined##"></a>一、null与undefined##</h2><p>undefined是全局对象的一个属性</p><p>当一个变量没有被赋值或者一个函数没有返回值或者访问对象某个不存在属性或者定义形参没有传实参</p><p>null代表对象的值未设定</p><p>对象没有初始化时的值为null</p><h2 id="二、数据分类的本质区别"><a href="#二、数据分类的本质区别" class="headerlink" title="二、数据分类的本质区别##"></a><strong>二、数据分类的本质区别</strong>##</h2><p>基本数据类型直接存储在栈内存中，占据内存小，属于频繁被调用的数据，引用数据类型存储在堆内存中，在占内存中存储数据指针，当解释器寻找引用值时，会检索其在栈中的地址，取得地址后从堆内存中获取实体</p><p>##<strong>三、</strong>typeof判断null和undefined类型##</p><p>undefined通过typeof判断值为undefined（typeof函数返回值为String类型）</p><p>null通过typeof返回值为object</p><p>总结：undefined是对象未被赋予初始值，null是对象被人为赋予空对象</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript判断对象类型的方法</title>
      <link href="/2023/03/24/js%E5%88%A4%E6%96%AD%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95/"/>
      <url>/2023/03/24/js%E5%88%A4%E6%96%AD%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一、四种返回类型的方法"><a href="#一、四种返回类型的方法" class="headerlink" title="一、四种返回类型的方法##"></a>一、四种返回类型的方法##</h2><p>1.typeof   基本类型返回其类型，引用类型除函数返回function，其余返回object</p><p>2.instanceof  主要用于区分引用数据类型，原理是检测当前的类型在当前实例的原型链上</p><p>原型链：未实例化对象通过prototype或者实例化对象通过_proto获得原型对象，再使用proto向上获取原型对象的实例对象即object，再由object向上得到null的链条</p><p><img src="https://img-blog.csdnimg.cn/1ccbdee4f468444dae832fb574ec733d.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NjUwNTg0NQ==,size_16,color_FFFFFF,t_70#pic_center"></p><p>使用例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 定义构造函数</span><br><span class="line">function C () &#123;&#125;</span><br><span class="line">function D () &#123;&#125;</span><br><span class="line">// 实例化一个 o 对象</span><br><span class="line">var o = new C()</span><br><span class="line">// true，true --&gt; C.prototype 在 o 的原型链上</span><br><span class="line">console.log(o instanceof C)</span><br></pre></td></tr></table></figure><p>3.Object.prototype.toString.call()</p><p>判断类型的确切类型，尤其对于object，相较于typeof将数组，日期，正则等引用类型都返回object</p><p>object.prototype.toString.call返回更为详细</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">判断原生引用类型：</span><br><span class="line"></span><br><span class="line">a 函数类型</span><br><span class="line"></span><br><span class="line">Function fn()&#123;console.log(“test”);&#125;</span><br><span class="line">Object.prototype.toString.call(fn);//”[object Function]”</span><br><span class="line">b 日期类型</span><br><span class="line"></span><br><span class="line">var date = new Date();</span><br><span class="line">Object.prototype.toString.call(date);//”[object Date]”</span><br><span class="line">c 数组类型</span><br><span class="line"></span><br><span class="line">var arr = [1,2,3];</span><br><span class="line">Object.prototype.toString.call(arr);//”[object Array]”</span><br><span class="line">d 正则表达式</span><br><span class="line"></span><br><span class="line">var reg = /[hbc]at/gi;</span><br><span class="line">Object.prototype.toString.call(arr);//”[object Array]”</span><br><span class="line">e 自定义类型</span><br><span class="line"></span><br><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">var person = new Person(&quot;Rose&quot;, 18);</span><br><span class="line">Object.prototype.toString.call(arr); //”[object Object]”</span><br></pre></td></tr></table></figure><p>4.constructor</p><p>区分数组函数对象类型，且不会把原型链上的类加入进来</p><p>示例1</p><p>下面代码可以检测对象和数组的类型，以此可以过滤对象、数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var a =[];</span><br><span class="line"></span><br><span class="line">if (o.constructor == Object) document.write(&quot;o 是对象&quot;);</span><br><span class="line"></span><br><span class="line">if (a.constructor == Array) document.write(&quot;a 是数组&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结合 typeof 运算符和 constructor 原型属性，可以检测不同类型的数据。表中列举了常用类型数据的检测结果。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的数据类型</title>
      <link href="/2023/03/24/JavaScript%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/03/24/JavaScript%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基础数据类型简单数据类型"><a href="#一、基础数据类型简单数据类型" class="headerlink" title="一、基础数据类型简单数据类型##"></a>一、基础数据类型简单数据类型##</h2><p>Number,string,boolean,bigInt,Symbol,Null,Undefined</p><h2 id="二、引用数据类型复杂数据类型"><a href="#二、引用数据类型复杂数据类型" class="headerlink" title="二、引用数据类型复杂数据类型##"></a>二、引用数据类型复杂数据类型##</h2><p>通常用Object代表，普通对象，数组，数组，正则表达式，日期，Math函数都属于Object</p><p>##三、数据分类的本质区别##</p><p>基本数据类型直接存储在栈中，属于被频繁调用的数据，引用数据类型存储在堆内存中，占据空间大。当解释器寻找引用值时，会检索其在栈中的地址，取得地址后会从堆中获得实体</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三栏布局实现方法</title>
      <link href="/2023/03/23/%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
      <url>/2023/03/23/%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>##一、什么三栏布局</p><p>三栏布局指的是三个内容撑起盒子，左右宽度固定，中间盒子宽度自适应且一般情况下内容较多为保证渲染快通常把中间盒子写在最前面</p><p>实现三栏布局的通常方法是圣杯布局和双飞翼布局</p><p>##二、圣杯布局</p><p>三个盒子设置浮动</p><p>左右盒子设置定宽度，中间盒子设置width为100%</p><p>左盒子设置左边距100%，右盒子设置左边距为自身宽度（这里是100px）</p><p>父盒子清除浮动（这里使用BFC方式清除浮动overfloat：hidden;）,撑开父元素高度</p><p>例子：</p><p>html</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;father&quot;&gt;</span><br><span class="line">     &lt;div class=&quot;middle&quot;&gt;middle&lt;/div&gt;</span><br><span class="line">     &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;</span><br><span class="line">     &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.father&#123;</span><br><span class="line">        padding: 0px 20px;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">    .middle&#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    .left&#123;</span><br><span class="line">        float: left;</span><br><span class="line">        width: 100px;</span><br><span class="line">        position: relative;</span><br><span class="line">        margin-left: -100%;</span><br><span class="line">    &#125;</span><br><span class="line">    .right&#123;</span><br><span class="line">        float: left;</span><br><span class="line">        width: 100px;</span><br><span class="line">        position: relative;</span><br><span class="line">        margin-left: -100px;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="三、双飞翼布局"><a href="#三、双飞翼布局" class="headerlink" title="三、双飞翼布局"></a>三、双飞翼布局</h2><p>三个盒子设置浮动,middle盒子增加内部盒子，并设置margin</p><p>左右盒子设置定宽度，中间盒子设置width为100%</p><p>左盒子设置左边距100%，右盒子设置左边距为自身宽度（这里是100px）</p><p>父盒子清除浮动（这里使用BFC方式清除浮动overfloat：hidden;）,撑开父元素高度</p><p>例子</p><p>html</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;father&quot;&gt;</span><br><span class="line">     &lt;div class=&quot;middle&quot;&gt;&lt;div class=&quot;middleInner&quot;&gt;middle&lt;/div&gt;&lt;/div&gt;</span><br><span class="line">     &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;</span><br><span class="line">     &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.father&#123;</span><br><span class="line">        padding: 0px 20px;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">    .middle&#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    .left&#123;</span><br><span class="line">        float: left;</span><br><span class="line">        width: 100px;</span><br><span class="line">        position: relative;</span><br><span class="line">        margin-left: -100%;</span><br><span class="line">    &#125;</span><br><span class="line">    .right&#123;</span><br><span class="line">        float: left;</span><br><span class="line">        width: 100px;</span><br><span class="line">        position: relative;</span><br><span class="line">        margin-left: -100px;</span><br><span class="line">    &#125;</span><br><span class="line">    .middleInner&#123;</span><br><span class="line">        margin: auto;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>圣杯布局缺点，middle width小于left width是出错</p><p>优点，不需要添加dom节点</p><p>双飞翼缺点：多dom节点</p><p>优点：不容易变型</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>未知宽高元素水平居中垂直居中方式</title>
      <link href="/2023/03/23/CSS%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95/"/>
      <url>/2023/03/23/CSS%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>##一、使用定位变化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">position:absolute;</span><br><span class="line">left:50%;</span><br><span class="line">transform:translate(-50%,0)</span><br></pre></td></tr></table></figure><p>因为是以子元素的左边为基准，不算是完全的水平居中，需要再让子元素向左平移一丢丢(子元素宽度一半的距离)。如果前期不知道子元素的宽度，就可以用transform的translate属性了。transform里面的百分比全都是相对于子元素本身来说的，要跟上面left的50%区分开。</p><p>##二、使用flex布局</p><p>对父元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display:flex;</span><br><span class="line">justify-content:center;</span><br><span class="line">align-items:center;</span><br></pre></td></tr></table></figure><h2 id="三、设置父级为网格元素"><a href="#三、设置父级为网格元素" class="headerlink" title="三、设置父级为网格元素"></a>三、设置父级为网格元素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display:grid;</span><br><span class="line">justify-content:center;</span><br><span class="line">align-items:center;</span><br></pre></td></tr></table></figure><p>三四方法只适用于IE11以上支持，目前大部分ie版本很高，很多网站使用三四居中方法</p><h2 id="四、table-cell"><a href="#四、table-cell" class="headerlink" title="四、table-cell"></a>四、table-cell</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display:table-cell;</span><br><span class="line">text-align:center;</span><br><span class="line">vertical-align:middle;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习笔记</title>
      <link href="/2023/03/22/vue/"/>
      <url>/2023/03/22/vue/</url>
      
        <content type="html"><![CDATA[<h1 id="VUE生命周期"><a href="#VUE生命周期" class="headerlink" title="VUE生命周期"></a>VUE生命周期</h1><p>以下主要从几个方面来讲：</p><p>1.vue的生命周期是什么和执行顺序。</p><p>2.vue中内置的方法 属性和vue生命周期的运行顺序（methods、computed、data、watch）.</p><p>一、vue的生命周期是什么</p><p>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、卸载等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。</p><p>在组件中具体的方法有:</p><p>  beforeCreate、created(此时需说明可以在created中首次拿到data中定义的数据)、beforeMount、mounted(此时需说明dom树渲染结束，可访问dom结构)、beforeUpdate、updated、beforeDestroy、destroyed</p><p>二、vue中内置的方法 属性和vue生命周期的运行顺序（methods、computed、data、watch、props)</p><p>  props &#x3D;&gt; methods &#x3D;&gt;data &#x3D;&gt; computed &#x3D;&gt; watch; </p><h1 id="Vue中computed和watch的区别"><a href="#Vue中computed和watch的区别" class="headerlink" title="Vue中computed和watch的区别"></a>Vue中computed和watch的区别</h1><p>**计算属性computed : **</p><p>\1. 支持缓存，只有依赖数据发生改变，才会重新进行计算</p><p>\2. 不支持异步，当computed内有异步操作时无效，无法监听数据的变化</p><p>3.computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</p><p>\4. 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</p><p>5.如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</p><h2 id="侦听属性watch："><a href="#侦听属性watch：" class="headerlink" title="侦听属性watch："></a><strong>侦听属性watch：</strong></h2><p>\1. 不支持缓存，数据变，直接会触发相应的操作；</p><p>2.watch支持异步；</p><p>3.监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</p><p>\4. 当一个属性发生变化时，需要执行对应的操作；一对多；</p><p>\5. 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，</p><p>　　immediate：组件加载立即触发回调函数执行，当值第一次进行绑定的时候并不会触发watch监听，使用immediate则可以在最初绑定的时候执行。</p><p>　　deep: 深度监听，为了发现<strong>对象内部值</strong>的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。</p><p>如果只是监听obj内的某一个属性变化，可以直接obj.key进行监听。</p><h2 id="v-for循环key的作用"><a href="#v-for循环key的作用" class="headerlink" title="v-for循环key的作用"></a>v-for循环key的作用</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>v-for循环时为什么要加key。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>问这个问题时，好多人再先回答的都是页面有警告，编辑器有提示，我会直接说不考虑报错和提示的问题，或者会问如果不加key的话，页面会不会出现什么异常情况。有的人会说是一个标识，标识他的唯一性，我会继续追问为什么要标识唯一性呢，不加又怎么样？</p><h3 id="期望答案"><a href="#期望答案" class="headerlink" title="期望答案"></a>期望答案</h3><p>vue的dom渲染是虚拟dom，数据发生变化时，diff算法会只比较更改的部分，如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。举例说明：有一个列表我们现在在中间插入了一个元素，diff算法会默认复用之前的列表并在最后追加一个，如果列表存在选中一类的状态则会随着复用出现绑定错误的情况而不是跟着原元素，key的作用就可以给他一个标识，让状态跟着数据渲染。(这一块是我自己的一个大概理解，表述不太清楚，具体的可以去查一下文档，本文就不具体描述此问题了。)</p><h2 id="nextTick作用"><a href="#nextTick作用" class="headerlink" title="$nextTick作用"></a>$nextTick作用</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>$nextTick用过吗，有什么作用。</p><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>问到这个问题时，很多人都会说到可以处理异步，而往下追问为什么要用nextTick，他解决了什么问题，不用他会怎么样的时候就很多人说不上来了。</p><h3 id="期望答案-1"><a href="#期望答案-1" class="headerlink" title="期望答案"></a>期望答案</h3><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。(官网解释)解决的问题：有些时候在改变数据后立即要对dom进行操作，此时获取到的dom仍是获取到的是数据刷新前的dom，无法满足需要，这个时候就用到了$nextTick。</p><h2 id="set作用"><a href="#set作用" class="headerlink" title="$set作用"></a>$set作用</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>vue中的$set用过吗，为什么要用它，解决了什么问题</p><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>这个问题知道的人就基本都能说出来，但是不知道的就是一点不了解，有的还会说到es6的set结构</p><h3 id="期望答案-2"><a href="#期望答案-2" class="headerlink" title="期望答案"></a>期望答案</h3><p>向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty &#x3D; ‘hi’)(官方示例)</p><p>我自己的理解就是，在vue中对一个对象内部进行一些修改时，vue没有监听到变化无法触发视图的更新，此时来使用$set来触发更新，使视图更新为最新的数据。</p><h2 id="组件间的传值"><a href="#组件间的传值" class="headerlink" title="组件间的传值"></a>组件间的传值</h2><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><p>说一下组件间的传值方式，你知道的所有方式都说一下</p><h3 id="期望答案-3"><a href="#期望答案-3" class="headerlink" title="期望答案"></a>期望答案</h3><ol><li>provide &#x2F; inject这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。</li><li>Vue.observable让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象。返回的对象可以直接用于渲染函数和计算属性内，并且会在发生改变时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const state = Vue.observable(&#123; count: 0 &#125;)const Demo = &#123;  render(h) &#123;    return h(&#x27;button&#x27;, &#123;      on: &#123; click: () =&gt; &#123; state.count++ &#125;&#125;    &#125;, `count is: $&#123;state.count&#125;`)  &#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>$attrs包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind&#x3D;”$attrs” 传入内部组件——在创建高级别的组件时非常有用。</li><li>$listeners包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on&#x3D;”$listeners” 传入内部组件——在创建更高层次的组件时非常有用。</li><li>props</li><li>$emit</li><li>eventbus</li><li>vuex</li><li>$parent &#x2F; $children &#x2F; ref</li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFC块级格式化上下文</title>
      <link href="/2023/03/22/BFC%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
      <url>/2023/03/22/BFC%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p>##一、什么是BFC</p><p>BFC块级格式化上下文，是web页面一块独立开发的渲染区域，内部元素的渲染不会影响边界以外的元素。</p><p><strong>总结:</strong></p><p><strong>1,每一个BFC区域只包括其子元素，不包括其子元素的子元素。</strong></p><p><strong>2,每一个BFC区域都是独立隔绝的,互不影响</strong></p><p>##二、BFC布局规则</p><p>内部盒子会在垂直方向，一个接着一个地放置。</p><p>Box垂直的方向由margin决定。</p><p>同属于一个BFC的两个相邻的Box的margin会发生重叠。</p><p>外盒子margin box的左边与包含块的border box的左边接触（从左往右格式化）</p><p>BFC区域不与float重叠，浮动元素参与盒子高度计算</p><h2 id="三、BFC形成条件"><a href="#三、BFC形成条件" class="headerlink" title="三、BFC形成条件"></a>三、BFC形成条件</h2><p>1.设置float为左右</p><p>2.设置position为absolute或者fixed</p><p>3.overflow设置为hidden，auto，scroll</p><p>4.display为flex或者inline-block</p><h2 id="四、BFC解决问题"><a href="#四、BFC解决问题" class="headerlink" title="四、BFC解决问题"></a>四、BFC解决问题</h2><p>清除浮动，通常使用BFC方式为overflow：hidden</p><h2 id="五、其他布局"><a href="#五、其他布局" class="headerlink" title="五、其他布局"></a>五、其他布局</h2><p>IFC 内联格式上下文</p><p>GFC 网格布局格式化上下文</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS设置尺寸的单位</title>
      <link href="/2023/03/22/CSS%E8%AE%BE%E7%BD%AE%E5%B0%BA%E5%AF%B8%E7%9A%84%E5%8D%95%E4%BD%8D/"/>
      <url>/2023/03/22/CSS%E8%AE%BE%E7%BD%AE%E5%B0%BA%E5%AF%B8%E7%9A%84%E5%8D%95%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="一、五个单位"><a href="#一、五个单位" class="headerlink" title="一、五个单位"></a>一、五个单位</h2><p>1.px:px是绝对单位</p><p>2.em:在网页上，一个em是网页浏览器的基础文本尺寸的高度，默认状态下是16px。相对于他本身的字体大小（但他本身字体大小是相对于父级字体大小的）</p><p>3.rem相对于根元素的字体大小</p><p>4.vw相对于可视化窗口的宽（1vw就是1%窗口宽度）</p><p>5.vh相对于可视化窗口的高（1vh就是1%窗口高度）</p><h2 id="二、实现响应式布局"><a href="#二、实现响应式布局" class="headerlink" title="二、实现响应式布局"></a>二、实现响应式布局</h2><p>一般采用rem＋媒体查询或者rem＋vw来实现响应式布局。原理是当窗口大小发生变化时，通过媒体查询或vw改变根元素的字体大小，从而改变以rem为单位的元素大小。</p><p>##三、什么是媒体查询</p><p>##1.媒体查询（Media Query）是CSS3新语法。</p><p>使用@media查询，可以针对不同的媒体类型定义不同的样式<br>@media可以针对不同的屏幕尺寸设置不同的样式<br>当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面<br>目前针对很多苹果手机、Android手机，平板等设备都用得到媒体查询</p><h2 id="2-语法规范"><a href="#2-语法规范" class="headerlink" title="2. 语法规范"></a>2. 语法规范</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@media mediatype and|not|only (media feature)&#123;</span><br><span class="line">      css-code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用@media开通 注意@符号</li><li>mediatype 媒体类型</li><li>关键字 and not only</li><li>media feature 媒体特性，必须有小括号包含</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS样式优先级顺序</title>
      <link href="/2023/03/22/%E6%A0%B7%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7%E9%A1%BA%E5%BA%8F/"/>
      <url>/2023/03/22/%E6%A0%B7%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、-important-与优先级"><a href="#一、-important-与优先级" class="headerlink" title="一、!important 与优先级"></a>一、!important 与优先级</h2><p>css 的样式优先级计算的例外规则-!important规则，为 css 样式优先级“最高级”，从作用结果上看，不管内联样式，还是百八十嵌套层的样式选择器组合，都可以被 !important 覆盖。</p><p><strong>例如：</strong>下面这个优先级权重其实已经很高的样式，会轻易被 !important 作用的样式覆盖。</p><p>.text {</p><pre><code>color: green !important;</code></pre><p>}<br>body #main .box p span {</p><pre><code>color: red;</code></pre><p>}</p><h2 id="二、引入方式的优先级"><a href="#二、引入方式的优先级" class="headerlink" title="二、引入方式的优先级"></a>二、引入方式的优先级</h2><p>行内样式的优先级高于嵌入式和外链，如果使用选择器相同就看先后顺序，后面插入会覆盖前面插入的样式</p><h2 id="三、选择器优先级"><a href="#三、选择器优先级" class="headerlink" title="三、选择器优先级"></a>三、选择器优先级</h2><p>id选择器#&gt;类选择器(.)，伪类选择器(:hover,:active,:first-child)，属性选择器(a[target])&gt;后代选择器(空格)，伪元素选择器(::before,::after)&gt;子类选择器(&gt;)相邻(+)兄弟选择器(~)&gt;通配符选择器(*)</p><h2 id="四、继承样式"><a href="#四、继承样式" class="headerlink" title="四、继承样式"></a>四、继承样式</h2><h2 id="五、浏览器默认样式"><a href="#五、浏览器默认样式" class="headerlink" title="五、浏览器默认样式"></a>五、浏览器默认样式</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS浮动</title>
      <link href="/2023/03/22/CSS%E6%B5%AE%E5%8A%A8/"/>
      <url>/2023/03/22/CSS%E6%B5%AE%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、不同元素的float浮动"><a href="#一、不同元素的float浮动" class="headerlink" title="一、不同元素的float浮动##"></a>一、不同元素的float浮动##</h2><p>图片使用float可以实现图片环绕效果</p><p>块级元素使用实现同行排列</p><p>行内元素使用浮动可以设置width，height属性，同时同方向对齐盒子</p><h2 id="二、float脱离标准流"><a href="#二、float脱离标准流" class="headerlink" title="二、float脱离标准流##"></a><strong>二、float脱离标准流</strong>##</h2><p>设置了浮动元素脱离标准流</p><p>元素不再占用原来的空间，如果父元素没有设置宽高，需要原来元素撑开，会导致父元素高度塌陷</p><p>同时影响父元素后面兄弟元素的布局</p><p>##<strong>三、</strong>清除浮动的方法##</p><p>1.伪元素清除浮动</p><p>给父元素设置</p><p>.clearfix::after{</p><pre><code>display: block;  /* 使其成为块级元素后*/content: &quot;&quot;;    /*为伪元素加入空内容，以便伪元素中不会有内容显示在页面中*/height: 0;       /* 为使伪元素不影响页面布局，将伪元素高度设置为0*/clear: both;     /* 清除浮动*/&#125;.clearfix &#123; *zoom:1; &#125;  /*兼容IE6、IE7 */</code></pre><p>2.浮动父元素添加</p><p>.clearfix{ overflow：hidden&#x2F;auto }</p><p>3.额外元素法</p><p>在需要清除浮动的元素后面添加一个空的div（不推荐）</p><p>因为它没有浏览器默认样式，没有特殊功能，而且一般不会被css样式化，所以这种方法也是比较常见和常用的方法。但是不太推荐，因为会造成多余的dom。</p><blockquote><p><code>clear：both</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS盒模型</title>
      <link href="/2023/03/22/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/03/22/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>盒模型是CSS控制页面布局的一个非常重要的概念，页面上的所有元素，包括文本、图像、超级链接、div块等，都可以被看作盒子。</strong></p><p><strong>由盒子将页面中的元素包含在一个矩形区域内，这个矩形区域则称为“盒模型”。</strong></p><p>一、盒模型的组成<br>内容</p><p>内容（content）是盒子里的“物品”，是盒模型中必须有的部分，可以是网页上的任何元素，如文本、图片、视频等各种信息。</p><p>内外边距</p><p>分为外边距（margin）是盒模型与其他盒模型之间的距离，内边距（padding）是盒模型边框border与content内容的距离，</p><p>定义盒模型边界语法格式如下（分多种使用方式，具体使用依据应用场景）：</p><p>margin: 上下距离，左右距离;  </p><p>margin: 四周边距；</p><p>margin：top，right，bottom，left ；</p><p>padding类似</p><p>边框</p><p>边框（border）是盒模型中介于填充（padding）和边界（margin）之间的分界线。</p><p>（1）边框样式</p><p>（2）边框宽度</p><p>（3）边框颜色</p><p>举个例子</p><p>代码</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=utf-8&gt;&lt;style type=&quot;text/css&quot;&gt;div &#123;width: 200px;background-color: #EFEFEF;margin: 10px;padding: 10px;&#125;.b1 &#123;border-style: inset;border-width: 10px;border-color: rgb(100%, 0%, 0%);&#125;.b2 &#123;border-style: double;border-width: thick;border-color: black;;&#125;.b3 &#123;border: groove thin rgb(255, 255, 0);&#125;.b4 &#123;border: #000 medium dashed;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;b1&quot;&gt;边框设置1&lt;/div&gt;&lt;div class=&quot;b2&quot;&gt;边框设置2&lt;/div&gt;&lt;div class=&quot;b3&quot;&gt;边框设置3&lt;/div&gt;&lt;div class=&quot;b4&quot;&gt;边框设置4&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>二、盒的类型<br>CSS中的盒子可分为block类型与inline类型，使用display属性来定义。</p><p>代码</p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=utf-8&gt;&lt;title&gt;block、inline、inline-block对比&lt;/title&gt;&lt;style&gt;div.div1 &#123;display: block; /*div默认值*/width: 120px;height: 40px;margin: 2px;background-color: green;&#125;div.div2 &#123;display: inline; /*修改为inline类型*/width: 120px;height: 40px;margin: 2px;background-color: blue;&#125;div.div3 &#123;display: inline-block; /*inline-block类型*/width: 120px;height: 40px;margin: 2px;background-color: red;&#125;div.div4 &#123;display: inline-block;margin: 2px;background-color: grey;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;div1&quot;&gt;block类型&lt;/div&gt;&lt;div class=&quot;div1&quot;&gt;block类型&lt;/div&gt;&lt;hr/&gt;&lt;div class=&quot;div2&quot;&gt;inline类型&lt;/div&gt;&lt;div class=&quot;div2&quot;&gt;inline类型&lt;/div&gt;&lt;hr/&gt;&lt;h3&gt;inline-block类型，设置width和height属性&lt;/h3&gt;&lt;div class=&quot;div3&quot;&gt;inline-block类型&lt;/div&gt;&lt;div class=&quot;div3&quot;&gt;inline-block类型&lt;/div&gt;&lt;hr/&gt;&lt;h3&gt;inline-block类型，无width和height属性&lt;/h3&gt;&lt;div class=&quot;div4&quot;&gt;inline-block类型&lt;/div&gt;&lt;div class=&quot;div4&quot;&gt;inline-block类型&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p> block类型是独占一行，而inline是可一个多个在一行，拓展的inline-block则是把block转换成与inline相似</p><p>三、标准盒模型和怪异盒模型</p><p>标准盒模型总宽度&#x3D;width+margin(左右)+padding（左右）border（左右）</p><p>怪异盒模型总宽度&#x3D;width+margin（左右）（width已经包含了padding和border值）</p><p>可以使用CSS box-sizing改变</p><p>content-box（标准盒子）</p><p>border-box（怪异盒子）</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html语义化</title>
      <link href="/2023/03/22/html%E8%AF%AD%E4%B9%89%E5%8C%96/"/>
      <url>/2023/03/22/html%E8%AF%AD%E4%B9%89%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>##<strong>一、什么是HTML语义化</strong>##</p><p>什么的HTML语义化，顾名思义，HTML语义化就是可以不通过了解HTML的内容，就可以知道这个部分所代表的的意义。</p><p>通过html语义化构建页面，可以避免大篇幅使用无语义的标签，样式文件未加载时，页面结构清晰。 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。</p><p>##<strong>二、什么是HTML语义化标签</strong>##</p><p>语义化标签比较容易理解：简单举一个例子就很容易理解：</p><p></p> //代表这是一行文字语义化标签优势：<p>利于页面内容结构化、利于无CSS页面可读、利于seo、利于代码可读</p><p>##<strong>三、常见语义化标签</strong>##</p><title>：定义文档的标题（注：只能在head标签内出现）。<hn>：h1~h6，分级标题，<h1> 与 <title> 协调有利于搜索引擎优化。<ul>：无序列表。<ol>：有序列表。<header>：页眉通常包括网站标志、主导航、全站链接以及搜索框。<nav>：标记导航。<main>：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。<article>：定义外部的内容，其中的内容独立于文档的其余部分。<section>：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。<aside>：定义其所处内容之外的内容。如侧栏、文章的一组链接、广告、友情链接、相关产品列表等。<footer>：页脚，只有当父级是body时，才是整个页面的页脚。<small>：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权。<strong>：和 em 标签一样，用于强调文本，但它强调的程度更强一些。<em>：将其中的文本表示为强调的内容，表现为斜体。<mark>：使用黄色突出显示部分文本。<figure>：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin）。<figcaption>：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置。<cite>：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。<blockquoto>：定义块引用，块引用拥有它们自己的空间。<q>：短的引述（跨浏览器问题，尽量避免使用）。<time>：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。<abbr>：简称或缩写。<dfn>：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。<address>：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）。<del>：移除的内容，定义文档中已被删除的文本。<ins>：添加的内容，定义文档中添加的文本<code>：标记代码。<meter>：定义已知范围或分数值内的标量测量。（Internet Explorer 不支持 meter 标签）<progress>：定义运行中的进度（进程）。]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript初识</title>
      <link href="/2023/03/22/TS1/"/>
      <url>/2023/03/22/TS1/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript-基础语法"><a href="#TypeScript-基础语法" class="headerlink" title="TypeScript 基础语法"></a>TypeScript 基础语法</h1><p>TypeScript 程序由以下几个部分组成：</p><ul><li>模块</li><li>函数</li><li>变量</li><li>语句和表达式</li><li>注释</li></ul><h3 id="第一个-TypeScript-程序"><a href="#第一个-TypeScript-程序" class="headerlink" title="第一个 TypeScript 程序"></a>第一个 TypeScript 程序</h3><p>我们可以使用以下 TypeScript 程序来输出 “Hello World” ：</p><blockquote><p>const hello : string &#x3D; “Hello World!”</p><p>console.log(hello)</p></blockquote><p>最后我们使用 node 命令来执行该 js 代码。</p><blockquote><p>$ node Runoob.jsHello World</p><p>Hello World</p></blockquote><p>TypeScript 面向对象编程实例：</p><p><code>class Site &#123;    name():void &#123;       console.log(&quot;Runoob&quot;)    &#125; &#125; var obj = new Site(); obj.name();</code></p><p>以上实例定义了一个类 Site，该类有一个方法 name()，该方法在终端上输出字符串 Runoob。</p><p>new 关键字创建类的对象，该对象调用方法 name()。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-Cli脚手架</title>
      <link href="/2023/03/22/vue-cli/"/>
      <url>/2023/03/22/vue-cli/</url>
      
        <content type="html"><![CDATA[<p>一、什么是VueCLI<br>1、如果你只是简单写几个Vue的Demo程序，那么你不需要VueCLI脚手架。<br>2、如果你在开发大型项目，那么你需要，并且必然需要使用VueCLI。<br>使用Vue.js开发大型应用时，我们需要考虑代码目录结构、项目结构和部署、热加载、代码单元测试等事情。<br>如果每个项目都要手动完成这些工作，那么无疑效率比较低效，所以通常我们会使用一些脚手架工具来帮助完成这些事情。<br>3、CLI是什么意思？<br>CLI是Commond-Line Interface，翻译为命令行界面，俗称脚手架。<br>VueCLI是一个官方发布vue.js项目脚手架。<br>使用VueCLI可以快速搭建vue开发环境以及对应的webpack配置。</p><p>4、脚手架依赖于node.js和webpack<br>二、安装Vue CLI脚手架<br>&#x2F;&#x2F;默认安装脚手架3<br>npm install -g @vue&#x2F;cli</p><p>&#x2F;&#x2F;安装脚手架2<br>npm install -g @vue&#x2F;cli-init</p><p>&#x2F;&#x2F;脚手架2创建项目<br>vue init webpack my-project</p><p>&#x2F;&#x2F;脚手架3创建项目<br>vue create my-project</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VueX学习</title>
      <link href="/2023/03/22/vueX/"/>
      <url>/2023/03/22/vueX/</url>
      
        <content type="html"><![CDATA[<p>一.Vuex是什么？<br> vuex官方解释<br>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><p>二.使用场景<br>Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。</p><p>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 store 模式就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。</p><p>三.安装<br>方法一：<br>在脚手架 创建项目时勾选vuex的选项系统会自动创建</p><p> 方法二：npm  或Yarn安装<br>npm install vuex@next –save<br>yarn add vuex@next –save</p><p>四.配置<br>如果采用脚手架方式进行创建，无需任何操作，可以忽略此步骤</p><p>新建store文件-&gt;index.js，进行如下配置，在main.js中进行引入</p><p>import Vue from ‘vue’<br>import Vuex from ‘vuex’</p><p>Vue.use(Vuex)</p><p>export default new Vuex.Store({<br>  &#x2F;&#x2F;数据，相当于data<br>  state: {<br>​<br>  },<br>  getters: {<br>​<br>  },<br>  &#x2F;&#x2F;里面定义方法，操作state方发<br>  mutations: {<br>​<br>  },<br>  &#x2F;&#x2F; 操作异步操作mutation<br>  actions: {<br>​<br>  },<br>  modules: {<br>​<br>  },<br>})</p><p> main.js中</p><p> 五.核心概念<br>vuex中一共有五个状态 State  Getter  Mutation   Action   Module  下面进行详细讲解</p><p>5.1  State<br>提供唯一的公共数据源，所有共享的数据统一放到store的state进行储存，相似与data</p><p> 在vuex中state中定义数据，可以在任何组件中进行调用</p><p>import Vue from ‘vue’<br>import Vuex from ‘vuex’</p><p>Vue.use(Vuex)</p><p>export default new Vuex.Store({<br>  &#x2F;&#x2F;数据，相当于data<br>  state: {<br>    name:”张三”,<br>    age:12,<br>    count:0<br>  },<br>})<br> 调用：</p><p>方法一：</p><p>在标签中直接使用</p><p> 方法二：</p><p>this.$store.state.全局数据名称<br>方法三：</p><p>从vuex中按需导入mapstate函数</p><p>import { mapState } from “vuex”;<br>注意：当前组件需要的全局数据，映射为当前组件computed属性</p><p>5.2 Mutation<br>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的事件类型 (type)和一个回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p><p> 在vuex中定义：</p><p>其中参数state参数是必须的，也可以自己传递一个参数，如下代码，进行计数器的加减操作，加法操作时可以根据所传递参数大小进行相加，减法操作没有传参每次减一</p><p>在组件中使用：</p><p> 定义两个按钮进行加减操作</p><p> 方法一：</p><p>注意：使用commit触发Mutation操作</p><p>methods:{<br>&#x2F;&#x2F;加法<br>btn(){<br>this.$store.commit(“addcount”,10)     &#x2F;&#x2F;每次加十<br>}<br>&#x2F;&#x2F;减法<br>btn1(){<br>this.$store.commit(“reduce”)<br>}<br>}<br>方法二：</p><p>使用辅助函数进行操作，具体方法同上</p><p> 5.3  Action ——进行异步操作<br>Action和Mutation相似，一般不用Mutation 异步操作，若要进行异步操作，使用Action</p><p>原因：为了方便devtools打个快照存下来，方便管理维护。所以说这个只是规范，而不是逻辑的不允许，只是为了让这个工具能够追踪数据变化而已</p><p>在vuex中定义：</p><p>将上面的减法操作改为异步操作</p><p> 在组件中使用：</p><p>方法一：</p><p>直接使用  dispatch触发Action函数</p><p>this.$store.dispatch(“asynAdd”)<br>方法二：</p><p>使用辅助函数</p><p> 5.4 Getter<br>类似于vue中的computed，进行缓存，对于Store中的数据进行加工处理形成新的数据</p><p> 具体操作类似于前几种，这里不做具体说明</p><p>5.5  Modules<br>当遇见大型项目时，数据量大，store就会显得很臃肿</p><p>为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p><p> 默认情况下，模块内部的 action 和 mutation 仍然是注册在全局命名空间的——这样使得多个模块能够对同一个 action 或 mutation 作出响应。</p><p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇BLOG</title>
      <link href="/2023/03/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87BLOG/"/>
      <url>/2023/03/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87BLOG/</url>
      
        <content type="html"><![CDATA[<p>Hello，之前使用的Halo搭建了一个博客，后来发现了借用github域名搭建博客的技术，就也搭建了一个<br>不定期更新博客内容<br>hexo静态页面更新真累…</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gossip </tag>
            
            <tag> 关于我 </tag>
            
            <tag> Hello，World </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/03/19/hello-world/"/>
      <url>/2023/03/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gossip </tag>
            
            <tag> 关于我 </tag>
            
            <tag> Hello，World </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
