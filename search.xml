<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>扩展运算符（...）</title>
      <link href="/2023/03/25/%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88...%EF%BC%89/"/>
      <url>/2023/03/25/%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88...%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>##一、字面量</p><p>属性简洁表示方法ES6允许对象的属性直接写变量，这时候属性名是变量名，属性值是变量值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;Jack&quot;</span><br><span class="line">var age = 19</span><br><span class="line">var person=&#123;</span><br><span class="line">  name,</span><br><span class="line">  age,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意字面量简写需要提前定义并建议赋值</p><p>##二、扩展运算符作用</p><p>在语法上展开数组，字面量对象，字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//一下定义了两个字面量a和b，用拓展运算符号将两个对象展开赋值给c</span><br><span class="line">var name =&quot;Jack&quot;</span><br><span class="line">var age = 19</span><br><span class="line">var sex = &quot;man&quot;</span><br><span class="line">var school = &quot;zj&quot;</span><br><span class="line">var a =&#123;name,age&#125;</span><br><span class="line">var b =&#123;sex,school&#125;</span><br><span class="line">var c =&#123;...b,...a&#125;</span><br><span class="line">console.log(c)</span><br><span class="line">//结果为&#123;sex: &#x27;man&#x27;, school: &#x27;zj&#x27;, name: &#x27;Jack&#x27;, age: 19&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="三、扩展运算符使用场景"><a href="#三、扩展运算符使用场景" class="headerlink" title="三、扩展运算符使用场景"></a>三、扩展运算符使用场景</h2><p>等价于apply的方式、将数组展开为构造函数的参数、字面量数组或字符串连接不需要使用concat等方法了、构造字面量对象时,进行浅克隆或者属性拷贝</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Js变量提升</title>
      <link href="/2023/03/25/Js%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
      <url>/2023/03/25/Js%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
      
        <content type="html"><![CDATA[<p>##一、变量提升</p><p>js中let和const定义的变量不会提升，只有var定义的变量会提升，变量提升只提升声明，赋值并不会提升，函数声明提升先于变量</p><p>变量提升的优点：可以在初始化之前访问变量，在声明前调用函数</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Js全局执行上下文</title>
      <link href="/2023/03/25/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
      <url>/2023/03/25/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p>##一、什么是执行上下文</p><p>执行上下文是js的执行环境，它存放了js的变量，作用域链规则，和this的指向</p><p>执行上下文分为三种：</p><p>全局执行上下文：当代码编译时创建</p><p>函数执行上下文：当执行到某一函数时创建</p><p>eval执行上下文：执行eval函数时创建</p><p>##二、javascript代码的执行过程</p><p>一段js代码的执行过程中，先是会进行编译阶段，js引擎会将代码进行编译，再进入执行阶段</p><p>也就是说，js代码是按照“段”来执行的，具体就是全局代码就是一段代码，函数执行也算一段代码，编译也是按照“段”来编译的，也就是一整个js代码会出现多个编译阶段</p><p>编译阶段<br>编译阶段是一个很复杂的过程，这里只是简单的介绍：</p><p>编译阶段完成两件事情：创建执行上下文和生成可执行代码<br>执行上下文就包括变量环境和词法环境和this指向等，创建执行上下文的过程：<br>如果是普通变量的话，js引擎会将该变量添加到变量环境中并初始化为undefined<br>如果是函数声明的话，js引擎会将函数定义添加到变量环境中，然后将函数名执行该函数的位置（内存）<br>接着，js引擎就会把其他的代码编译为字节码，生成可执行代码<br>执行阶段<br>编译阶段完成后，js引擎开始执行可执行代码，按照顺序一行一行执行，当遇到函数或者变量时，会在变量环境中寻找，找不到的话就会报错</p><p>如果遇到赋值语句时，就会将值赋值给变量</p><h2 id="三、this指向"><a href="#三、this指向" class="headerlink" title="三、this指向"></a>三、this指向</h2><h4 id="1-为什么需要this？"><a href="#1-为什么需要this？" class="headerlink" title="1.为什么需要this？"></a>1.为什么需要this？</h4><p>编程中需要调用对象自身的成员变量，而JavaScript的作用域链规则无法完成</p><p>####2.不同执行上下文的this机制</p><p>全局上下文，this指向全局变量</p><p>函数上下文中，按函数的调用方式区分</p><p>全局环境中调用一个函数，则函数的this指向全局变量window，如果使用对象.成员函数，this指向的时调用函数的对象。</p><p>普通函数中this严格模式下undefined，非严格模式指向window</p><p>new 关键字构建好了一个新对象，并且构造函数中的 this 其实就是新对象本身。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Js作用域与闭包</title>
      <link href="/2023/03/25/Js%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/"/>
      <url>/2023/03/25/Js%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>##一、Js闭包</p><p>闭包是一个函数和词法环境捆绑在一起形成的组合。一般就是一个A函数中return一个B函数，外界可以通过这个B函数访问A函数的变量。这个时候形成了B函数的变量背包，这个背包A函数执行完毕也不会销毁，且这个变量背包外界只能通过B函数访问</p><p>##二、闭包的原理</p><p>作用域链，即当前函数可以访问当前函数和上一级函数的变量</p><h2 id="三、闭包解决的问题"><a href="#三、闭包解决的问题" class="headerlink" title="三、闭包解决的问题"></a>三、闭包解决的问题</h2><p>能够使函数在外部访问到内部变量，能让内部变量在函数调用完成后不被销毁</p><p>闭包带来的问题</p><p>内存泄露，内存溢出</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map与foreach区别</title>
      <link href="/2023/03/25/map%E4%B8%8Eforeach%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/03/25/map%E4%B8%8Eforeach%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>##一、map与foreach基本用法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3,4,5]</span><br><span class="line">a.foreach((item,index,arr)=&gt;&#123;</span><br><span class="line">执行内容</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>匿名函数支持三个参数，分别为item当前对象，index当前索引，arr原数组</p><p>map用法类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2,3,4,5]</span><br><span class="line">a.map((item,index,arr)=&gt;&#123;</span><br><span class="line">执行内容</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>##二、foreach和map的不同点</p><p>(1)map()方法会得到一个新的数组并返回，forEach()会修改原来的数组。</p><p>map遍历的后的数组通常都是生成一个新的数组，新的数组的值发生变化，当前遍历的数组值不会变化。</p><p>(2)forEach()允许callback更改原始数组的元素。map()返回新的数组。</p><p>forEach遍历通常都是直接引入当前遍历数组的内存地址，生成的数组的值发生变化，当前遍历的数组对应的值也会发生变化。</p><p>总结：foreach中无法返回值，map可以再callback中return来返回值</p><p>map，foreach可以使用匿名函数支持的arr参数来修改原数组</p><h2 id="三、foreach和map的共同点"><a href="#三、foreach和map的共同点" class="headerlink" title="三、foreach和map的共同点"></a>三、foreach和map的共同点</h2><p>(1)都是循环遍历数组中的每一项。</p><p>(2)每次执行匿名函数都支持三个参数，参数分别为item(当前每一项)，index(索引值)，arr(原数组)。</p><p>(3)匿名函数中的this都是指向window。</p><p>(4)只能遍历数组。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6箭头函数</title>
      <link href="/2023/03/25/es6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
      <url>/2023/03/25/es6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>##一、什么箭头函数</p><p>箭头函数是es6新特性，es6允许使用箭头函数定义函数，语法上类似匿名函数</p><p>如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var f = (name)=&gt;&#123;console.log(name)&#125;</span><br><span class="line">//等同于</span><br><span class="line">function f(name)&#123;</span><br><span class="line">  console.log(name)</span><br><span class="line">&#125;</span><br><span class="line">//调用f函数，输出“Jack”</span><br><span class="line">f(&quot;Jack&quot;)</span><br><span class="line">//另外,下面此时返回值是对象&#123;a:&#x27;1&#x27;,b:&#x27;2&#x27;&#125;</span><br><span class="line">var ff = (name)=&gt;(&#123;a:&#x27;1&#x27;,b:&#x27;2&#x27;&#125;)</span><br></pre></td></tr></table></figure><p>##二、箭头函数指向原则</p><p>我们知道，在匿名函数中，this是有指向的</p><p>例如 数组foreach,map函数，this指向的是window</p><p>但是在箭头函数中this没有指向，因为箭头函数没有prototype，但是箭头函数会从外部上下文获取this指向</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组与伪数组</title>
      <link href="/2023/03/25/%E6%95%B0%E7%BB%84%E4%B8%8E%E4%BC%AA%E6%95%B0%E7%BB%84/"/>
      <url>/2023/03/25/%E6%95%B0%E7%BB%84%E4%B8%8E%E4%BC%AA%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>yi常见的伪数组</p><p>##一、常见的伪数组</p><p>1函数内部的 <code>arguments</code></p><p>2 DOM 对象列表（比如通过 <code>document.getElementsByTags</code> 得到的列表）</p><p>3 jQuery 对象（比如 <code>$(&quot;div&quot;)</code> ）</p><p>伪数组是一个 Object，而真实的数组是一个 Array。</p><h2 id="二、伪数组与数组区别"><a href="#二、伪数组与数组区别" class="headerlink" title="二、伪数组与数组区别"></a>二、伪数组与数组区别</h2><p>数组类型为Array，伪数组类型Object，数组伪数组都可以使用length查看长度，使用for in遍历，使用[index]来获取数组对象，</p><p>但伪数组不能使用数组方法，修改数组长度</p><h2 id="三、伪数组转换"><a href="#三、伪数组转换" class="headerlink" title="三、伪数组转换"></a>三、伪数组转换</h2><p>Array.prototype.slice.call(伪数组)  -[].slice.call(伪数组)  -Array.from(伪数组) 转换后的数组长度由 <code>length</code> 属性决定。索引不连续时转换结果是连续的，会自动补位。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>null和undefined区别</title>
      <link href="/2023/03/24/null%E5%92%8Cundefined%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/03/24/null%E5%92%8Cundefined%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="一、null与undefined"><a href="#一、null与undefined" class="headerlink" title="一、null与undefined##"></a>一、null与undefined##</h2><p>undefined是全局对象的一个属性</p><p>当一个变量没有被赋值或者一个函数没有返回值或者访问对象某个不存在属性或者定义形参没有传实参</p><p>null代表对象的值未设定</p><p>对象没有初始化时的值为null</p><h2 id="二、数据分类的本质区别"><a href="#二、数据分类的本质区别" class="headerlink" title="二、数据分类的本质区别##"></a><strong>二、数据分类的本质区别</strong>##</h2><p>基本数据类型直接存储在栈内存中，占据内存小，属于频繁被调用的数据，引用数据类型存储在堆内存中，在占内存中存储数据指针，当解释器寻找引用值时，会检索其在栈中的地址，取得地址后从堆内存中获取实体</p><p>##<strong>三、</strong>typeof判断null和undefined类型##</p><p>undefined通过typeof判断值为undefined（typeof函数返回值为String类型）</p><p>null通过typeof返回值为object</p><p>总结：undefined是对象未被赋予初始值，null是对象被人为赋予空对象</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript判断对象类型的方法</title>
      <link href="/2023/03/24/js%E5%88%A4%E6%96%AD%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95/"/>
      <url>/2023/03/24/js%E5%88%A4%E6%96%AD%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一、四种返回类型的方法"><a href="#一、四种返回类型的方法" class="headerlink" title="一、四种返回类型的方法##"></a>一、四种返回类型的方法##</h2><p>1.typeof   基本类型返回其类型，引用类型除函数返回function，其余返回object</p><p>2.instanceof  主要用于区分引用数据类型，原理是检测当前的类型在当前实例的原型链上</p><p>原型链：未实例化对象通过prototype或者实例化对象通过_proto获得原型对象，再使用proto向上获取原型对象的实例对象即object，再由object向上得到null的链条</p><p><img src="https://img-blog.csdnimg.cn/1ccbdee4f468444dae832fb574ec733d.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81NjUwNTg0NQ==,size_16,color_FFFFFF,t_70#pic_center"></p><p>使用例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 定义构造函数</span><br><span class="line">function C () &#123;&#125;</span><br><span class="line">function D () &#123;&#125;</span><br><span class="line">// 实例化一个 o 对象</span><br><span class="line">var o = new C()</span><br><span class="line">// true，true --&gt; C.prototype 在 o 的原型链上</span><br><span class="line">console.log(o instanceof C)</span><br></pre></td></tr></table></figure><p>3.Object.prototype.toString.call()</p><p>判断类型的确切类型，尤其对于object，相较于typeof将数组，日期，正则等引用类型都返回object</p><p>object.prototype.toString.call返回更为详细</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">判断原生引用类型：</span><br><span class="line"></span><br><span class="line">a 函数类型</span><br><span class="line"></span><br><span class="line">Function fn()&#123;console.log(“test”);&#125;</span><br><span class="line">Object.prototype.toString.call(fn);//”[object Function]”</span><br><span class="line">b 日期类型</span><br><span class="line"></span><br><span class="line">var date = new Date();</span><br><span class="line">Object.prototype.toString.call(date);//”[object Date]”</span><br><span class="line">c 数组类型</span><br><span class="line"></span><br><span class="line">var arr = [1,2,3];</span><br><span class="line">Object.prototype.toString.call(arr);//”[object Array]”</span><br><span class="line">d 正则表达式</span><br><span class="line"></span><br><span class="line">var reg = /[hbc]at/gi;</span><br><span class="line">Object.prototype.toString.call(arr);//”[object Array]”</span><br><span class="line">e 自定义类型</span><br><span class="line"></span><br><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">var person = new Person(&quot;Rose&quot;, 18);</span><br><span class="line">Object.prototype.toString.call(arr); //”[object Object]”</span><br></pre></td></tr></table></figure><p>4.constructor</p><p>区分数组函数对象类型，且不会把原型链上的类加入进来</p><p>示例1</p><p>下面代码可以检测对象和数组的类型，以此可以过滤对象、数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var a =[];</span><br><span class="line"></span><br><span class="line">if (o.constructor == Object) document.write(&quot;o 是对象&quot;);</span><br><span class="line"></span><br><span class="line">if (a.constructor == Array) document.write(&quot;a 是数组&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结合 typeof 运算符和 constructor 原型属性，可以检测不同类型的数据。表中列举了常用类型数据的检测结果。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的数据类型</title>
      <link href="/2023/03/24/JavaScript%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/03/24/JavaScript%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基础数据类型简单数据类型"><a href="#一、基础数据类型简单数据类型" class="headerlink" title="一、基础数据类型简单数据类型##"></a>一、基础数据类型简单数据类型##</h2><p>Number,string,boolean,bigInt,Symbol,Null,Undefined</p><h2 id="二、引用数据类型复杂数据类型"><a href="#二、引用数据类型复杂数据类型" class="headerlink" title="二、引用数据类型复杂数据类型##"></a>二、引用数据类型复杂数据类型##</h2><p>通常用Object代表，普通对象，数组，数组，正则表达式，日期，Math函数都属于Object</p><p>##三、数据分类的本质区别##</p><p>基本数据类型直接存储在栈中，属于被频繁调用的数据，引用数据类型存储在堆内存中，占据空间大。当解释器寻找引用值时，会检索其在栈中的地址，取得地址后会从堆中获得实体</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三栏布局实现方法</title>
      <link href="/2023/03/23/%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
      <url>/2023/03/23/%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>##一、什么三栏布局</p><p>三栏布局指的是三个内容撑起盒子，左右宽度固定，中间盒子宽度自适应且一般情况下内容较多为保证渲染快通常把中间盒子写在最前面</p><p>实现三栏布局的通常方法是圣杯布局和双飞翼布局</p><p>##二、圣杯布局</p><p>三个盒子设置浮动</p><p>左右盒子设置定宽度，中间盒子设置width为100%</p><p>左盒子设置左边距100%，右盒子设置左边距为自身宽度（这里是100px）</p><p>父盒子清除浮动（这里使用BFC方式清除浮动overfloat：hidden;）,撑开父元素高度</p><p>例子：</p><p>html</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;father&quot;&gt;</span><br><span class="line">     &lt;div class=&quot;middle&quot;&gt;middle&lt;/div&gt;</span><br><span class="line">     &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;</span><br><span class="line">     &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>css</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.father&#123;</span><br><span class="line">        padding: 0px 20px;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">    .middle&#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    .left&#123;</span><br><span class="line">        float: left;</span><br><span class="line">        width: 100px;</span><br><span class="line">        position: relative;</span><br><span class="line">        margin-left: -100%;</span><br><span class="line">    &#125;</span><br><span class="line">    .right&#123;</span><br><span class="line">        float: left;</span><br><span class="line">        width: 100px;</span><br><span class="line">        position: relative;</span><br><span class="line">        margin-left: -100px;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="三、双飞翼布局"><a href="#三、双飞翼布局" class="headerlink" title="三、双飞翼布局"></a>三、双飞翼布局</h2><p>三个盒子设置浮动,middle盒子增加内部盒子，并设置margin</p><p>左右盒子设置定宽度，中间盒子设置width为100%</p><p>左盒子设置左边距100%，右盒子设置左边距为自身宽度（这里是100px）</p><p>父盒子清除浮动（这里使用BFC方式清除浮动overfloat：hidden;）,撑开父元素高度</p><p>例子</p><p>html</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;father&quot;&gt;</span><br><span class="line">     &lt;div class=&quot;middle&quot;&gt;&lt;div class=&quot;middleInner&quot;&gt;middle&lt;/div&gt;&lt;/div&gt;</span><br><span class="line">     &lt;div class=&quot;left&quot;&gt;left&lt;/div&gt;</span><br><span class="line">     &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>CSS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.father&#123;</span><br><span class="line">        padding: 0px 20px;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">    .middle&#123;</span><br><span class="line">        width: 100%;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    .left&#123;</span><br><span class="line">        float: left;</span><br><span class="line">        width: 100px;</span><br><span class="line">        position: relative;</span><br><span class="line">        margin-left: -100%;</span><br><span class="line">    &#125;</span><br><span class="line">    .right&#123;</span><br><span class="line">        float: left;</span><br><span class="line">        width: 100px;</span><br><span class="line">        position: relative;</span><br><span class="line">        margin-left: -100px;</span><br><span class="line">    &#125;</span><br><span class="line">    .middleInner&#123;</span><br><span class="line">        margin: auto;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>圣杯布局缺点，middle width小于left width是出错</p><p>优点，不需要添加dom节点</p><p>双飞翼缺点：多dom节点</p><p>优点：不容易变型</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>未知宽高元素水平居中垂直居中方式</title>
      <link href="/2023/03/23/CSS%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95/"/>
      <url>/2023/03/23/CSS%E5%B1%85%E4%B8%AD%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>##一、使用定位变化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">position:absolute;</span><br><span class="line">left:50%;</span><br><span class="line">transform:translate(-50%,0)</span><br></pre></td></tr></table></figure><p>因为是以子元素的左边为基准，不算是完全的水平居中，需要再让子元素向左平移一丢丢(子元素宽度一半的距离)。如果前期不知道子元素的宽度，就可以用transform的translate属性了。transform里面的百分比全都是相对于子元素本身来说的，要跟上面left的50%区分开。</p><p>##二、使用flex布局</p><p>对父元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display:flex;</span><br><span class="line">justify-content:center;</span><br><span class="line">align-items:center;</span><br></pre></td></tr></table></figure><h2 id="三、设置父级为网格元素"><a href="#三、设置父级为网格元素" class="headerlink" title="三、设置父级为网格元素"></a>三、设置父级为网格元素</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display:grid;</span><br><span class="line">justify-content:center;</span><br><span class="line">align-items:center;</span><br></pre></td></tr></table></figure><p>三四方法只适用于IE11以上支持，目前大部分ie版本很高，很多网站使用三四居中方法</p><h2 id="四、table-cell"><a href="#四、table-cell" class="headerlink" title="四、table-cell"></a>四、table-cell</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display:table-cell;</span><br><span class="line">text-align:center;</span><br><span class="line">vertical-align:middle;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习笔记</title>
      <link href="/2023/03/22/vue/"/>
      <url>/2023/03/22/vue/</url>
      
        <content type="html"><![CDATA[<h1 id="VUE生命周期"><a href="#VUE生命周期" class="headerlink" title="VUE生命周期"></a>VUE生命周期</h1><p>以下主要从几个方面来讲：</p><p>1.vue的生命周期是什么和执行顺序。</p><p>2.vue中内置的方法 属性和vue生命周期的运行顺序（methods、computed、data、watch）.</p><p>一、vue的生命周期是什么</p><p>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、卸载等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。</p><p>在组件中具体的方法有:</p><p>  beforeCreate、created(此时需说明可以在created中首次拿到data中定义的数据)、beforeMount、mounted(此时需说明dom树渲染结束，可访问dom结构)、beforeUpdate、updated、beforeDestroy、destroyed</p><p>二、vue中内置的方法 属性和vue生命周期的运行顺序（methods、computed、data、watch、props)</p><p>  props &#x3D;&gt; methods &#x3D;&gt;data &#x3D;&gt; computed &#x3D;&gt; watch; </p><h1 id="Vue中computed和watch的区别"><a href="#Vue中computed和watch的区别" class="headerlink" title="Vue中computed和watch的区别"></a>Vue中computed和watch的区别</h1><p>**计算属性computed : **</p><p>\1. 支持缓存，只有依赖数据发生改变，才会重新进行计算</p><p>\2. 不支持异步，当computed内有异步操作时无效，无法监听数据的变化</p><p>3.computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</p><p>\4. 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</p><p>5.如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</p><h2 id="侦听属性watch："><a href="#侦听属性watch：" class="headerlink" title="侦听属性watch："></a><strong>侦听属性watch：</strong></h2><p>\1. 不支持缓存，数据变，直接会触发相应的操作；</p><p>2.watch支持异步；</p><p>3.监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</p><p>\4. 当一个属性发生变化时，需要执行对应的操作；一对多；</p><p>\5. 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，</p><p>　　immediate：组件加载立即触发回调函数执行，当值第一次进行绑定的时候并不会触发watch监听，使用immediate则可以在最初绑定的时候执行。</p><p>　　deep: 深度监听，为了发现<strong>对象内部值</strong>的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。</p><p>如果只是监听obj内的某一个属性变化，可以直接obj.key进行监听。</p><h2 id="v-for循环key的作用"><a href="#v-for循环key的作用" class="headerlink" title="v-for循环key的作用"></a>v-for循环key的作用</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>v-for循环时为什么要加key。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>问这个问题时，好多人再先回答的都是页面有警告，编辑器有提示，我会直接说不考虑报错和提示的问题，或者会问如果不加key的话，页面会不会出现什么异常情况。有的人会说是一个标识，标识他的唯一性，我会继续追问为什么要标识唯一性呢，不加又怎么样？</p><h3 id="期望答案"><a href="#期望答案" class="headerlink" title="期望答案"></a>期望答案</h3><p>vue的dom渲染是虚拟dom，数据发生变化时，diff算法会只比较更改的部分，如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。举例说明：有一个列表我们现在在中间插入了一个元素，diff算法会默认复用之前的列表并在最后追加一个，如果列表存在选中一类的状态则会随着复用出现绑定错误的情况而不是跟着原元素，key的作用就可以给他一个标识，让状态跟着数据渲染。(这一块是我自己的一个大概理解，表述不太清楚，具体的可以去查一下文档，本文就不具体描述此问题了。)</p><h2 id="nextTick作用"><a href="#nextTick作用" class="headerlink" title="$nextTick作用"></a>$nextTick作用</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>$nextTick用过吗，有什么作用。</p><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>问到这个问题时，很多人都会说到可以处理异步，而往下追问为什么要用nextTick，他解决了什么问题，不用他会怎么样的时候就很多人说不上来了。</p><h3 id="期望答案-1"><a href="#期望答案-1" class="headerlink" title="期望答案"></a>期望答案</h3><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。(官网解释)解决的问题：有些时候在改变数据后立即要对dom进行操作，此时获取到的dom仍是获取到的是数据刷新前的dom，无法满足需要，这个时候就用到了$nextTick。</p><h2 id="set作用"><a href="#set作用" class="headerlink" title="$set作用"></a>$set作用</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>vue中的$set用过吗，为什么要用它，解决了什么问题</p><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>这个问题知道的人就基本都能说出来，但是不知道的就是一点不了解，有的还会说到es6的set结构</p><h3 id="期望答案-2"><a href="#期望答案-2" class="headerlink" title="期望答案"></a>期望答案</h3><p>向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty &#x3D; ‘hi’)(官方示例)</p><p>我自己的理解就是，在vue中对一个对象内部进行一些修改时，vue没有监听到变化无法触发视图的更新，此时来使用$set来触发更新，使视图更新为最新的数据。</p><h2 id="组件间的传值"><a href="#组件间的传值" class="headerlink" title="组件间的传值"></a>组件间的传值</h2><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><p>说一下组件间的传值方式，你知道的所有方式都说一下</p><h3 id="期望答案-3"><a href="#期望答案-3" class="headerlink" title="期望答案"></a>期望答案</h3><ol><li>provide &#x2F; inject这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。</li><li>Vue.observable让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象。返回的对象可以直接用于渲染函数和计算属性内，并且会在发生改变时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const state = Vue.observable(&#123; count: 0 &#125;)const Demo = &#123;  render(h) &#123;    return h(&#x27;button&#x27;, &#123;      on: &#123; click: () =&gt; &#123; state.count++ &#125;&#125;    &#125;, `count is: $&#123;state.count&#125;`)  &#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>$attrs包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind&#x3D;”$attrs” 传入内部组件——在创建高级别的组件时非常有用。</li><li>$listeners包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on&#x3D;”$listeners” 传入内部组件——在创建更高层次的组件时非常有用。</li><li>props</li><li>$emit</li><li>eventbus</li><li>vuex</li><li>$parent &#x2F; $children &#x2F; ref</li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFC块级格式化上下文</title>
      <link href="/2023/03/22/BFC%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
      <url>/2023/03/22/BFC%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      
        <content type="html"><![CDATA[<p>##一、什么是BFC</p><p>BFC块级格式化上下文，是web页面一块独立开发的渲染区域，内部元素的渲染不会影响边界以外的元素。</p><p><strong>总结:</strong></p><p><strong>1,每一个BFC区域只包括其子元素，不包括其子元素的子元素。</strong></p><p><strong>2,每一个BFC区域都是独立隔绝的,互不影响</strong></p><p>##二、BFC布局规则</p><p>内部盒子会在垂直方向，一个接着一个地放置。</p><p>Box垂直的方向由margin决定。</p><p>同属于一个BFC的两个相邻的Box的margin会发生重叠。</p><p>外盒子margin box的左边与包含块的border box的左边接触（从左往右格式化）</p><p>BFC区域不与float重叠，浮动元素参与盒子高度计算</p><h2 id="三、BFC形成条件"><a href="#三、BFC形成条件" class="headerlink" title="三、BFC形成条件"></a>三、BFC形成条件</h2><p>1.设置float为左右</p><p>2.设置position为absolute或者fixed</p><p>3.overflow设置为hidden，auto，scroll</p><p>4.display为flex或者inline-block</p><h2 id="四、BFC解决问题"><a href="#四、BFC解决问题" class="headerlink" title="四、BFC解决问题"></a>四、BFC解决问题</h2><p>清除浮动，通常使用BFC方式为overflow：hidden</p><h2 id="五、其他布局"><a href="#五、其他布局" class="headerlink" title="五、其他布局"></a>五、其他布局</h2><p>IFC 内联格式上下文</p><p>GFC 网格布局格式化上下文</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS设置尺寸的单位</title>
      <link href="/2023/03/22/CSS%E8%AE%BE%E7%BD%AE%E5%B0%BA%E5%AF%B8%E7%9A%84%E5%8D%95%E4%BD%8D/"/>
      <url>/2023/03/22/CSS%E8%AE%BE%E7%BD%AE%E5%B0%BA%E5%AF%B8%E7%9A%84%E5%8D%95%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="一、五个单位"><a href="#一、五个单位" class="headerlink" title="一、五个单位"></a>一、五个单位</h2><p>1.px:px是绝对单位</p><p>2.em:在网页上，一个em是网页浏览器的基础文本尺寸的高度，默认状态下是16px。相对于他本身的字体大小（但他本身字体大小是相对于父级字体大小的）</p><p>3.rem相对于根元素的字体大小</p><p>4.vw相对于可视化窗口的宽（1vw就是1%窗口宽度）</p><p>5.vh相对于可视化窗口的高（1vh就是1%窗口高度）</p><h2 id="二、实现响应式布局"><a href="#二、实现响应式布局" class="headerlink" title="二、实现响应式布局"></a>二、实现响应式布局</h2><p>一般采用rem＋媒体查询或者rem＋vw来实现响应式布局。原理是当窗口大小发生变化时，通过媒体查询或vw改变根元素的字体大小，从而改变以rem为单位的元素大小。</p><p>##三、什么是媒体查询</p><p>##1.媒体查询（Media Query）是CSS3新语法。</p><p>使用@media查询，可以针对不同的媒体类型定义不同的样式<br>@media可以针对不同的屏幕尺寸设置不同的样式<br>当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面<br>目前针对很多苹果手机、Android手机，平板等设备都用得到媒体查询</p><h2 id="2-语法规范"><a href="#2-语法规范" class="headerlink" title="2. 语法规范"></a>2. 语法规范</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@media mediatype and|not|only (media feature)&#123;</span><br><span class="line">      css-code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用@media开通 注意@符号</li><li>mediatype 媒体类型</li><li>关键字 and not only</li><li>media feature 媒体特性，必须有小括号包含</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS样式优先级顺序</title>
      <link href="/2023/03/22/%E6%A0%B7%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7%E9%A1%BA%E5%BA%8F/"/>
      <url>/2023/03/22/%E6%A0%B7%E5%BC%8F%E4%BC%98%E5%85%88%E7%BA%A7%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、-important-与优先级"><a href="#一、-important-与优先级" class="headerlink" title="一、!important 与优先级"></a>一、!important 与优先级</h2><p>css 的样式优先级计算的例外规则-!important规则，为 css 样式优先级“最高级”，从作用结果上看，不管内联样式，还是百八十嵌套层的样式选择器组合，都可以被 !important 覆盖。</p><p><strong>例如：</strong>下面这个优先级权重其实已经很高的样式，会轻易被 !important 作用的样式覆盖。</p><p>.text {</p><pre><code>color: green !important;</code></pre><p>}<br>body #main .box p span {</p><pre><code>color: red;</code></pre><p>}</p><h2 id="二、引入方式的优先级"><a href="#二、引入方式的优先级" class="headerlink" title="二、引入方式的优先级"></a>二、引入方式的优先级</h2><p>行内样式的优先级高于嵌入式和外链，如果使用选择器相同就看先后顺序，后面插入会覆盖前面插入的样式</p><h2 id="三、选择器优先级"><a href="#三、选择器优先级" class="headerlink" title="三、选择器优先级"></a>三、选择器优先级</h2><p>id选择器#&gt;类选择器(.)，伪类选择器(:hover,:active,:first-child)，属性选择器(a[target])&gt;后代选择器(空格)，伪元素选择器(::before,::after)&gt;子类选择器(&gt;)相邻(+)兄弟选择器(~)&gt;通配符选择器(*)</p><h2 id="四、继承样式"><a href="#四、继承样式" class="headerlink" title="四、继承样式"></a>四、继承样式</h2><h2 id="五、浏览器默认样式"><a href="#五、浏览器默认样式" class="headerlink" title="五、浏览器默认样式"></a>五、浏览器默认样式</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS浮动</title>
      <link href="/2023/03/22/CSS%E6%B5%AE%E5%8A%A8/"/>
      <url>/2023/03/22/CSS%E6%B5%AE%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、不同元素的float浮动"><a href="#一、不同元素的float浮动" class="headerlink" title="一、不同元素的float浮动##"></a>一、不同元素的float浮动##</h2><p>图片使用float可以实现图片环绕效果</p><p>块级元素使用实现同行排列</p><p>行内元素使用浮动可以设置width，height属性，同时同方向对齐盒子</p><h2 id="二、float脱离标准流"><a href="#二、float脱离标准流" class="headerlink" title="二、float脱离标准流##"></a><strong>二、float脱离标准流</strong>##</h2><p>设置了浮动元素脱离标准流</p><p>元素不再占用原来的空间，如果父元素没有设置宽高，需要原来元素撑开，会导致父元素高度塌陷</p><p>同时影响父元素后面兄弟元素的布局</p><p>##<strong>三、</strong>清除浮动的方法##</p><p>1.伪元素清除浮动</p><p>给父元素设置</p><p>.clearfix::after{</p><pre><code>display: block;  /* 使其成为块级元素后*/content: &quot;&quot;;    /*为伪元素加入空内容，以便伪元素中不会有内容显示在页面中*/height: 0;       /* 为使伪元素不影响页面布局，将伪元素高度设置为0*/clear: both;     /* 清除浮动*/&#125;.clearfix &#123; *zoom:1; &#125;  /*兼容IE6、IE7 */</code></pre><p>2.浮动父元素添加</p><p>.clearfix{ overflow：hidden&#x2F;auto }</p><p>3.额外元素法</p><p>在需要清除浮动的元素后面添加一个空的div（不推荐）</p><p>因为它没有浏览器默认样式，没有特殊功能，而且一般不会被css样式化，所以这种方法也是比较常见和常用的方法。但是不太推荐，因为会造成多余的dom。</p><blockquote><p><code>clear：both</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS盒模型</title>
      <link href="/2023/03/22/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/03/22/CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>盒模型是CSS控制页面布局的一个非常重要的概念，页面上的所有元素，包括文本、图像、超级链接、div块等，都可以被看作盒子。</strong></p><p><strong>由盒子将页面中的元素包含在一个矩形区域内，这个矩形区域则称为“盒模型”。</strong></p><p>一、盒模型的组成<br>内容</p><p>内容（content）是盒子里的“物品”，是盒模型中必须有的部分，可以是网页上的任何元素，如文本、图片、视频等各种信息。</p><p>内外边距</p><p>分为外边距（margin）是盒模型与其他盒模型之间的距离，内边距（padding）是盒模型边框border与content内容的距离，</p><p>定义盒模型边界语法格式如下（分多种使用方式，具体使用依据应用场景）：</p><p>margin: 上下距离，左右距离;  </p><p>margin: 四周边距；</p><p>margin：top，right，bottom，left ；</p><p>padding类似</p><p>边框</p><p>边框（border）是盒模型中介于填充（padding）和边界（margin）之间的分界线。</p><p>（1）边框样式</p><p>（2）边框宽度</p><p>（3）边框颜色</p><p>举个例子</p><p>代码</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=utf-8&gt;&lt;style type=&quot;text/css&quot;&gt;div &#123;width: 200px;background-color: #EFEFEF;margin: 10px;padding: 10px;&#125;.b1 &#123;border-style: inset;border-width: 10px;border-color: rgb(100%, 0%, 0%);&#125;.b2 &#123;border-style: double;border-width: thick;border-color: black;;&#125;.b3 &#123;border: groove thin rgb(255, 255, 0);&#125;.b4 &#123;border: #000 medium dashed;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;b1&quot;&gt;边框设置1&lt;/div&gt;&lt;div class=&quot;b2&quot;&gt;边框设置2&lt;/div&gt;&lt;div class=&quot;b3&quot;&gt;边框设置3&lt;/div&gt;&lt;div class=&quot;b4&quot;&gt;边框设置4&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>二、盒的类型<br>CSS中的盒子可分为block类型与inline类型，使用display属性来定义。</p><p>代码</p><pre><code>&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=utf-8&gt;&lt;title&gt;block、inline、inline-block对比&lt;/title&gt;&lt;style&gt;div.div1 &#123;display: block; /*div默认值*/width: 120px;height: 40px;margin: 2px;background-color: green;&#125;div.div2 &#123;display: inline; /*修改为inline类型*/width: 120px;height: 40px;margin: 2px;background-color: blue;&#125;div.div3 &#123;display: inline-block; /*inline-block类型*/width: 120px;height: 40px;margin: 2px;background-color: red;&#125;div.div4 &#123;display: inline-block;margin: 2px;background-color: grey;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;div1&quot;&gt;block类型&lt;/div&gt;&lt;div class=&quot;div1&quot;&gt;block类型&lt;/div&gt;&lt;hr/&gt;&lt;div class=&quot;div2&quot;&gt;inline类型&lt;/div&gt;&lt;div class=&quot;div2&quot;&gt;inline类型&lt;/div&gt;&lt;hr/&gt;&lt;h3&gt;inline-block类型，设置width和height属性&lt;/h3&gt;&lt;div class=&quot;div3&quot;&gt;inline-block类型&lt;/div&gt;&lt;div class=&quot;div3&quot;&gt;inline-block类型&lt;/div&gt;&lt;hr/&gt;&lt;h3&gt;inline-block类型，无width和height属性&lt;/h3&gt;&lt;div class=&quot;div4&quot;&gt;inline-block类型&lt;/div&gt;&lt;div class=&quot;div4&quot;&gt;inline-block类型&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p> block类型是独占一行，而inline是可一个多个在一行，拓展的inline-block则是把block转换成与inline相似</p><p>三、标准盒模型和怪异盒模型</p><p>标准盒模型总宽度&#x3D;width+margin(左右)+padding（左右）border（左右）</p><p>怪异盒模型总宽度&#x3D;width+margin（左右）（width已经包含了padding和border值）</p><p>可以使用CSS box-sizing改变</p><p>content-box（标准盒子）</p><p>border-box（怪异盒子）</p>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html语义化</title>
      <link href="/2023/03/22/html%E8%AF%AD%E4%B9%89%E5%8C%96/"/>
      <url>/2023/03/22/html%E8%AF%AD%E4%B9%89%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>##<strong>一、什么是HTML语义化</strong>##</p><p>什么的HTML语义化，顾名思义，HTML语义化就是可以不通过了解HTML的内容，就可以知道这个部分所代表的的意义。</p><p>通过html语义化构建页面，可以避免大篇幅使用无语义的标签，样式文件未加载时，页面结构清晰。 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。</p><p>##<strong>二、什么是HTML语义化标签</strong>##</p><p>语义化标签比较容易理解：简单举一个例子就很容易理解：</p><p></p> //代表这是一行文字语义化标签优势：<p>利于页面内容结构化、利于无CSS页面可读、利于seo、利于代码可读</p><p>##<strong>三、常见语义化标签</strong>##</p><title>：定义文档的标题（注：只能在head标签内出现）。<hn>：h1~h6，分级标题，<h1> 与 <title> 协调有利于搜索引擎优化。<ul>：无序列表。<ol>：有序列表。<header>：页眉通常包括网站标志、主导航、全站链接以及搜索框。<nav>：标记导航。<main>：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。<article>：定义外部的内容，其中的内容独立于文档的其余部分。<section>：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。<aside>：定义其所处内容之外的内容。如侧栏、文章的一组链接、广告、友情链接、相关产品列表等。<footer>：页脚，只有当父级是body时，才是整个页面的页脚。<small>：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权。<strong>：和 em 标签一样，用于强调文本，但它强调的程度更强一些。<em>：将其中的文本表示为强调的内容，表现为斜体。<mark>：使用黄色突出显示部分文本。<figure>：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin）。<figcaption>：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置。<cite>：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。<blockquoto>：定义块引用，块引用拥有它们自己的空间。<q>：短的引述（跨浏览器问题，尽量避免使用）。<time>：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。<abbr>：简称或缩写。<dfn>：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。<address>：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）。<del>：移除的内容，定义文档中已被删除的文本。<ins>：添加的内容，定义文档中添加的文本<code>：标记代码。<meter>：定义已知范围或分数值内的标量测量。（Internet Explorer 不支持 meter 标签）<progress>：定义运行中的进度（进程）。]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript初识</title>
      <link href="/2023/03/22/TS1/"/>
      <url>/2023/03/22/TS1/</url>
      
        <content type="html"><![CDATA[<h1 id="TypeScript-基础语法"><a href="#TypeScript-基础语法" class="headerlink" title="TypeScript 基础语法"></a>TypeScript 基础语法</h1><p>TypeScript 程序由以下几个部分组成：</p><ul><li>模块</li><li>函数</li><li>变量</li><li>语句和表达式</li><li>注释</li></ul><h3 id="第一个-TypeScript-程序"><a href="#第一个-TypeScript-程序" class="headerlink" title="第一个 TypeScript 程序"></a>第一个 TypeScript 程序</h3><p>我们可以使用以下 TypeScript 程序来输出 “Hello World” ：</p><blockquote><p>const hello : string &#x3D; “Hello World!”</p><p>console.log(hello)</p></blockquote><p>最后我们使用 node 命令来执行该 js 代码。</p><blockquote><p>$ node Runoob.jsHello World</p><p>Hello World</p></blockquote><p>TypeScript 面向对象编程实例：</p><p><code>class Site &#123;    name():void &#123;       console.log(&quot;Runoob&quot;)    &#125; &#125; var obj = new Site(); obj.name();</code></p><p>以上实例定义了一个类 Site，该类有一个方法 name()，该方法在终端上输出字符串 Runoob。</p><p>new 关键字创建类的对象，该对象调用方法 name()。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-Cli脚手架</title>
      <link href="/2023/03/22/vue-cli/"/>
      <url>/2023/03/22/vue-cli/</url>
      
        <content type="html"><![CDATA[<p>一、什么是VueCLI<br>1、如果你只是简单写几个Vue的Demo程序，那么你不需要VueCLI脚手架。<br>2、如果你在开发大型项目，那么你需要，并且必然需要使用VueCLI。<br>使用Vue.js开发大型应用时，我们需要考虑代码目录结构、项目结构和部署、热加载、代码单元测试等事情。<br>如果每个项目都要手动完成这些工作，那么无疑效率比较低效，所以通常我们会使用一些脚手架工具来帮助完成这些事情。<br>3、CLI是什么意思？<br>CLI是Commond-Line Interface，翻译为命令行界面，俗称脚手架。<br>VueCLI是一个官方发布vue.js项目脚手架。<br>使用VueCLI可以快速搭建vue开发环境以及对应的webpack配置。</p><p>4、脚手架依赖于node.js和webpack<br>二、安装Vue CLI脚手架<br>&#x2F;&#x2F;默认安装脚手架3<br>npm install -g @vue&#x2F;cli</p><p>&#x2F;&#x2F;安装脚手架2<br>npm install -g @vue&#x2F;cli-init</p><p>&#x2F;&#x2F;脚手架2创建项目<br>vue init webpack my-project</p><p>&#x2F;&#x2F;脚手架3创建项目<br>vue create my-project</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VueX学习</title>
      <link href="/2023/03/22/vueX/"/>
      <url>/2023/03/22/vueX/</url>
      
        <content type="html"><![CDATA[<p>一.Vuex是什么？<br> vuex官方解释<br>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><p>二.使用场景<br>Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。</p><p>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 store 模式就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。</p><p>三.安装<br>方法一：<br>在脚手架 创建项目时勾选vuex的选项系统会自动创建</p><p> 方法二：npm  或Yarn安装<br>npm install vuex@next –save<br>yarn add vuex@next –save</p><p>四.配置<br>如果采用脚手架方式进行创建，无需任何操作，可以忽略此步骤</p><p>新建store文件-&gt;index.js，进行如下配置，在main.js中进行引入</p><p>import Vue from ‘vue’<br>import Vuex from ‘vuex’</p><p>Vue.use(Vuex)</p><p>export default new Vuex.Store({<br>  &#x2F;&#x2F;数据，相当于data<br>  state: {<br>​<br>  },<br>  getters: {<br>​<br>  },<br>  &#x2F;&#x2F;里面定义方法，操作state方发<br>  mutations: {<br>​<br>  },<br>  &#x2F;&#x2F; 操作异步操作mutation<br>  actions: {<br>​<br>  },<br>  modules: {<br>​<br>  },<br>})</p><p> main.js中</p><p> 五.核心概念<br>vuex中一共有五个状态 State  Getter  Mutation   Action   Module  下面进行详细讲解</p><p>5.1  State<br>提供唯一的公共数据源，所有共享的数据统一放到store的state进行储存，相似与data</p><p> 在vuex中state中定义数据，可以在任何组件中进行调用</p><p>import Vue from ‘vue’<br>import Vuex from ‘vuex’</p><p>Vue.use(Vuex)</p><p>export default new Vuex.Store({<br>  &#x2F;&#x2F;数据，相当于data<br>  state: {<br>    name:”张三”,<br>    age:12,<br>    count:0<br>  },<br>})<br> 调用：</p><p>方法一：</p><p>在标签中直接使用</p><p> 方法二：</p><p>this.$store.state.全局数据名称<br>方法三：</p><p>从vuex中按需导入mapstate函数</p><p>import { mapState } from “vuex”;<br>注意：当前组件需要的全局数据，映射为当前组件computed属性</p><p>5.2 Mutation<br>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的事件类型 (type)和一个回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p><p> 在vuex中定义：</p><p>其中参数state参数是必须的，也可以自己传递一个参数，如下代码，进行计数器的加减操作，加法操作时可以根据所传递参数大小进行相加，减法操作没有传参每次减一</p><p>在组件中使用：</p><p> 定义两个按钮进行加减操作</p><p> 方法一：</p><p>注意：使用commit触发Mutation操作</p><p>methods:{<br>&#x2F;&#x2F;加法<br>btn(){<br>this.$store.commit(“addcount”,10)     &#x2F;&#x2F;每次加十<br>}<br>&#x2F;&#x2F;减法<br>btn1(){<br>this.$store.commit(“reduce”)<br>}<br>}<br>方法二：</p><p>使用辅助函数进行操作，具体方法同上</p><p> 5.3  Action ——进行异步操作<br>Action和Mutation相似，一般不用Mutation 异步操作，若要进行异步操作，使用Action</p><p>原因：为了方便devtools打个快照存下来，方便管理维护。所以说这个只是规范，而不是逻辑的不允许，只是为了让这个工具能够追踪数据变化而已</p><p>在vuex中定义：</p><p>将上面的减法操作改为异步操作</p><p> 在组件中使用：</p><p>方法一：</p><p>直接使用  dispatch触发Action函数</p><p>this.$store.dispatch(“asynAdd”)<br>方法二：</p><p>使用辅助函数</p><p> 5.4 Getter<br>类似于vue中的computed，进行缓存，对于Store中的数据进行加工处理形成新的数据</p><p> 具体操作类似于前几种，这里不做具体说明</p><p>5.5  Modules<br>当遇见大型项目时，数据量大，store就会显得很臃肿</p><p>为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p><p> 默认情况下，模块内部的 action 和 mutation 仍然是注册在全局命名空间的——这样使得多个模块能够对同一个 action 或 mutation 作出响应。</p><p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇BLOG</title>
      <link href="/2023/03/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87BLOG/"/>
      <url>/2023/03/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87BLOG/</url>
      
        <content type="html"><![CDATA[<p>Hello，之前使用的Halo搭建了一个博客，后来发现了借用github域名搭建博客的技术，就也搭建了一个<br>不定期更新博客内容<br>hexo静态页面更新真累…</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gossip </tag>
            
            <tag> 关于我 </tag>
            
            <tag> Hello，World </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/03/19/hello-world/"/>
      <url>/2023/03/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gossip </tag>
            
            <tag> 关于我 </tag>
            
            <tag> Hello，World </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
