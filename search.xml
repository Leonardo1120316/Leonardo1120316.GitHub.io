<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue学习笔记</title>
      <link href="/2023/03/22/vue/"/>
      <url>/2023/03/22/vue/</url>
      
        <content type="html"><![CDATA[<h1 id="VUE生命周期"><a href="#VUE生命周期" class="headerlink" title="VUE生命周期"></a>VUE生命周期</h1><p>以下主要从几个方面来讲：</p><p>1.vue的生命周期是什么和执行顺序。</p><p>2.vue中内置的方法 属性和vue生命周期的运行顺序（methods、computed、data、watch）.</p><p>一、vue的生命周期是什么</p><p>Vue实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、卸载等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。</p><p>在组件中具体的方法有:</p><p>  beforeCreate、created(此时需说明可以在created中首次拿到data中定义的数据)、beforeMount、mounted(此时需说明dom树渲染结束，可访问dom结构)、beforeUpdate、updated、beforeDestroy、destroyed</p><p>二、vue中内置的方法 属性和vue生命周期的运行顺序（methods、computed、data、watch、props)</p><p>  props &#x3D;&gt; methods &#x3D;&gt;data &#x3D;&gt; computed &#x3D;&gt; watch; </p><h1 id="Vue中computed和watch的区别"><a href="#Vue中computed和watch的区别" class="headerlink" title="Vue中computed和watch的区别"></a>Vue中computed和watch的区别</h1><p>**计算属性computed : **</p><p>\1. 支持缓存，只有依赖数据发生改变，才会重新进行计算</p><p>\2. 不支持异步，当computed内有异步操作时无效，无法监听数据的变化</p><p>3.computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值</p><p>\4. 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</p><p>5.如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。</p><h2 id="侦听属性watch："><a href="#侦听属性watch：" class="headerlink" title="侦听属性watch："></a><strong>侦听属性watch：</strong></h2><p>\1. 不支持缓存，数据变，直接会触发相应的操作；</p><p>2.watch支持异步；</p><p>3.监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</p><p>\4. 当一个属性发生变化时，需要执行对应的操作；一对多；</p><p>\5. 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，</p><p>　　immediate：组件加载立即触发回调函数执行，当值第一次进行绑定的时候并不会触发watch监听，使用immediate则可以在最初绑定的时候执行。</p><p>　　deep: 深度监听，为了发现<strong>对象内部值</strong>的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。</p><p>如果只是监听obj内的某一个属性变化，可以直接obj.key进行监听。</p><h2 id="v-for循环key的作用"><a href="#v-for循环key的作用" class="headerlink" title="v-for循环key的作用"></a>v-for循环key的作用</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>v-for循环时为什么要加key。</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>问这个问题时，好多人再先回答的都是页面有警告，编辑器有提示，我会直接说不考虑报错和提示的问题，或者会问如果不加key的话，页面会不会出现什么异常情况。有的人会说是一个标识，标识他的唯一性，我会继续追问为什么要标识唯一性呢，不加又怎么样？</p><h3 id="期望答案"><a href="#期望答案" class="headerlink" title="期望答案"></a>期望答案</h3><p>vue的dom渲染是虚拟dom，数据发生变化时，diff算法会只比较更改的部分，如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。举例说明：有一个列表我们现在在中间插入了一个元素，diff算法会默认复用之前的列表并在最后追加一个，如果列表存在选中一类的状态则会随着复用出现绑定错误的情况而不是跟着原元素，key的作用就可以给他一个标识，让状态跟着数据渲染。(这一块是我自己的一个大概理解，表述不太清楚，具体的可以去查一下文档，本文就不具体描述此问题了。)</p><h2 id="nextTick作用"><a href="#nextTick作用" class="headerlink" title="$nextTick作用"></a>$nextTick作用</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>$nextTick用过吗，有什么作用。</p><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>问到这个问题时，很多人都会说到可以处理异步，而往下追问为什么要用nextTick，他解决了什么问题，不用他会怎么样的时候就很多人说不上来了。</p><h3 id="期望答案-1"><a href="#期望答案-1" class="headerlink" title="期望答案"></a>期望答案</h3><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。(官网解释)解决的问题：有些时候在改变数据后立即要对dom进行操作，此时获取到的dom仍是获取到的是数据刷新前的dom，无法满足需要，这个时候就用到了$nextTick。</p><h2 id="set作用"><a href="#set作用" class="headerlink" title="$set作用"></a>$set作用</h2><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><p>vue中的$set用过吗，为什么要用它，解决了什么问题</p><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>这个问题知道的人就基本都能说出来，但是不知道的就是一点不了解，有的还会说到es6的set结构</p><h3 id="期望答案-2"><a href="#期望答案-2" class="headerlink" title="期望答案"></a>期望答案</h3><p>向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty &#x3D; ‘hi’)(官方示例)</p><p>我自己的理解就是，在vue中对一个对象内部进行一些修改时，vue没有监听到变化无法触发视图的更新，此时来使用$set来触发更新，使视图更新为最新的数据。</p><h2 id="组件间的传值"><a href="#组件间的传值" class="headerlink" title="组件间的传值"></a>组件间的传值</h2><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h3><p>说一下组件间的传值方式，你知道的所有方式都说一下</p><h3 id="期望答案-3"><a href="#期望答案-3" class="headerlink" title="期望答案"></a>期望答案</h3><ol><li>provide &#x2F; inject这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。</li><li>Vue.observable让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象。返回的对象可以直接用于渲染函数和计算属性内，并且会在发生改变时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const state = Vue.observable(&#123; count: 0 &#125;)const Demo = &#123;  render(h) &#123;    return h(&#x27;button&#x27;, &#123;      on: &#123; click: () =&gt; &#123; state.count++ &#125;&#125;    &#125;, `count is: $&#123;state.count&#125;`)  &#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>$attrs包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind&#x3D;”$attrs” 传入内部组件——在创建高级别的组件时非常有用。</li><li>$listeners包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on&#x3D;”$listeners” 传入内部组件——在创建更高层次的组件时非常有用。</li><li>props</li><li>$emit</li><li>eventbus</li><li>vuex</li><li>$parent &#x2F; $children &#x2F; ref</li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇BLOG</title>
      <link href="/2023/03/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87BLOG/"/>
      <url>/2023/03/19/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87BLOG/</url>
      
        <content type="html"><![CDATA[<p>Hello，之前使用的Halo搭建了一个博客，后来发现了借用github域名搭建博客的技术，就也搭建了一个<br>不定期更新博客内容<br>hexo静态页面更新真累…</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gossip </tag>
            
            <tag> 关于我 </tag>
            
            <tag> Hello，World </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/03/19/hello-world/"/>
      <url>/2023/03/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gossip </tag>
            
            <tag> 关于我 </tag>
            
            <tag> Hello，World </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
